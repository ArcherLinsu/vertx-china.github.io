---
title: "What's new in Vert.x 4.3"
category: releases
authors:
  - name: Julien Viet
    github_id: vietj
summary: >-
  See an overview of all new and exciting features in Vert.x 4.3, including ... and more.
pinned: true
---

Vert.x 4.3 comes with plenty of new exciting features.

Here is an overview of the most important features supported in Vert.x 4.3.

## Web Client URI templates

URI templates provide an alternative to HTTP request string URIs based on the https://datatracker.ietf.org/doc/html/rfc6570[URI Template RFC].

A Vert.x URI https://vertx.io/docs/vertx-uri-template/java/[template] can be created

```java
UriTemplate REQUEST_URI = UriTemplate.of("/users{/user}");
```

a web client can https://vertx.io/docs/vertx-web-client/java/#_uri_templates[use] to send a request

```java
client.get(80, "myserver.mycompany.com", REQUEST_URI)
  .setTemplateParam("user", "cooper")
  .send()
  .onSuccess(res ->
    System.out.println("Received response with status code" + res.statusCode()))
  .onFailure(err ->
    System.out.println("Something went wrong " + err.getMessage()));
```

URI templates expansion mechanism takes care of encoding parameter values, it can also handle lists and maps.

Several expansion https://vertx.io/docs/vertx-uri-template/java/#expansion_styles[styles] are available for each relevant part of a URI.

### Json Schema

Json Schema validation has received a major update. In 4.3 we introduce support for more drafts:

* Draft 4 (used by swagger and openapi 3.0)
* Draft 7 (generally used by many services)
* Draft 2019-09
* Draft 2020-12 (used by openapi 3.1)

This refactor required that the previous implementation was deprecated and will be replaced with a polyglot friendly
alternative. In a nutshell, the new API can be used as:

```java
// when dealing with multiple schema resources, we need a repository:
// 'options' defines the validation draft to be used, base uri, etc...
SchemaRepository repository = SchemaRepository.create(options);

// create a schema object
JsonSchema schema = JsonSchema.of(jsonObject);

// perform validation (if not using a repository)
schema.validate(anyObject, options);
// or
repository.validator(schema).validate();
```

This work lays the foundation for future support of openapi in vertx-web.

## Vert.x gRPC

Until 4.3, Vert.x gRPC support was built on top of gRPC Netty, it works very well yet with some friction:
Netty versions must be matched and often forced, incompatibility with Vert.x Web, etc...

The new gRPC stack for Vert.x gets rid of those limitations and provides a set of new exclusive features built on top of the
Vert.x HTTP/2 stack.

Beyond implementing the https://vertx.io/docs/vertx-grpc/java/#_stub_api[gRPC stub model],
Vert.x gRPC has a request/response API

```java
GrpcServer grpcServer = GrpcServer.server(vertx);

server.callHandler(GreeterGrpc.getSayHelloMethod(), request -> {

  request.handler(hello -> {

    GrpcServerResponse<HelloRequest, HelloReply> response = request.response();

    HelloReply reply = HelloReply.newBuilder().setMessage("Hello " + hello.getName()).build();

    response.end(reply);
  });
});

vertx.createHttpServer(options);
  .requestHandler(grpcServer)
  .listen();
```

This API can also be used with protobuf data instead of decoded protobuf, giving the opportunity to easily build gRPC
proxies with Vert.x:

```java
grpcServer.callHandler(clientReq -> {
  clientReq.pause();
  client.request(serverAddress).onSuccess(proxyReq -> {
    proxyReq.response().onSuccess(resp -> {
      GrpcServerResponse<Buffer, Buffer> bc = clientReq.response();
      resp.messageHandler(bc::writeMessage);
      resp.endHandler(v -> bc.end());
    });
    proxyReq.fullMethodName(clientReq.fullMethodName());
    clientReq.messageHandler(proxyReq::writeMessage);
    clientReq.endHandler(v -> proxyReq.end());
    clientReq.resume();
  });
});
```

Notice that the proxy does not need at any time to reference generated stubs, it works universally for any gRPC service.

The proxy can forward compressed messages without intermediate decompression if the proxied server
supports compression.

Finally the Vert.x gRPC server can be used within a Vert.x Web router:

```java
GreeterGrpc.GreeterImplBase service = new GreeterGrpc.GreeterImplBase() {
  @Override
  public void sayHello(HelloRequest request, StreamObserver<HelloReply> responseObserver) {
    responseObserver.onNext(HelloReply.newBuilder().setMessage("Hello " + request.getName()).build());
    responseObserver.onCompleted();
  }
};

GrpcServer grpcServer = GrpcServer.server(vertx);
GrpcServiceBridge serverStub = GrpcServiceBridge.bridge(service);
serverStub.bind(grpcServer);

router.consumes("application/grpc").handler(grpcServer);
```

### Extra HTTP compression algorithms

Vert.x HTTP server can https://vertx.io/docs/vertx-core/java/#_http_compression_algorithms[compress] brotli and gzstandard in addition of gzip.

to finish

### MySQL client pipelining support

The reactive MySQL client now supports pipelining like his elder brother the reactive PostgreSQL client.

### Kafka 3.0

todo

### Shared HTTP Client

todo

### Vertx Web

Figuring out the right order for handlers can be sometimes tricky.

In 4.3 we now do checks the order when multiple handlers are added under the same route and incorrect setup are signaled.

For example, adding a user handler before a body handler will raise an error:

```java
// Not allowed
router.route("/api")
  .handler(ctx -> {
    // some logic...
    System.out.println(ctx.body().toString());
    ctx.next();
  })
  .handler(BodyHandler.create());

// Allowed
router.route("/api")
  .handler(BodyHandler.create());
  .handler(ctx -> {
    // some logic...
    System.out.println(ctx.body().toString());
    ctx.next();
  })
```

In addition security handlers using callbacks, now ensure that callbacks are added in the right order, relieving from
creating temporary objects:

```java
router.route("/secure")
  .handler(OAuth2AuthHandler
    .create(vertx, oauth2, "http://localhost:8080/callback")
    .setupCallback(router.route("/callback")));
```

Previously a reference to the callback route had to be created before the oauth2 handler was added otherwise the
callback handler would be shaded.

Other small improvements were on processing the body of the request. We now cache the body which avoid parsing it's
content on each `ctx.getBodyAsXXX()` invocation.