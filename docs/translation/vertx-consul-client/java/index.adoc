= Vert.x Consul 客户端

https://www.consul.io[Consul] 是一个在你的应用架构中提供服务发现和配置管理的工具。
Vert.x 的 Consul 客户端允许应用与 Consul 系统通过阻塞或非阻塞的 HTTP 接口交互。

== 使用 Vert.x Consul 客户端

为了使用该项目， 将以下依赖添加到你的构建描述文件的 _依赖配置_ 中：

* Maven (在你的 `pom.xml` 中):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-consul-client</artifactId>
 <version>4.0.3</version>
</dependency>
----

* Gradle (在你的 `build.gradle` 文件中):

[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-consul-client:4.0.3'
----

== 创建客户端

只需使用工厂方法即可创建：

[source,java]
----
ConsulClient client = ConsulClient.create(vertx);
----

Consul 客户端也可以配置选项

[source,java]
----
ConsulClientOptions options = new ConsulClientOptions()
  .setHost("consul.example.com");

ConsulClient client = ConsulClient.create(vertx, options);
----

Consul 客户端支持以下配置：

`host`:: Consul 的主机地址。 默认是 `localhost`
`port`:: Consul 的 HTTP 接口地址。 默认是 `8500`
`timeout`:: 设置超时时间 (单位为毫秒) 如果在超时时间内请求没有返回任何数据，那么
处理器会收到一个失败的结果，请求也会被关闭
`aclToken`:: ACL 签名。 如果设置了该参数， 客户端在请求 Consul 时会在
查询参数中携带 "?token" 参数。 如果没有提供，那么签名为空，会使用对应的 '匿名'
ACL 策略
`dc`:: 数据中心名称。 如果设置了该参数， 客户端在请求 Consul 时会在
查询参数中携带 "?dc" 参数。 如果没有提供，那么会默认查询当前的 Consul agent 的数据中心

ConsulClient 的选项类继承了 `vertx-web-client` 模块的 WebClientOptions 类，
因此还可以提供很多设置。 请参阅相关文档。

== 使用接口

客户端接口参见 `link:../../apidocs/io/vertx/ext/consul/ConsulClient.html[ConsulClient]`。 接口的格式与 Consul 的
HTTP 接口非常相像，Consul 的 HTTP 接口参见 https://www.consul.io/docs/agent/http.html[Consul API 文档]

=== 阻塞查询

Consul 的某些接口支持名为 "阻塞查询" 的特性。 阻塞查询基于长轮询以查询结果的潜在
变化。 每个支持阻塞查询的接口都提供了一个唯一标识 (index)，以代表
所请求资源的当前状态。 以下参数配置用于阻塞查询：

`index`:: 该值用于表示 Consul 客户端期望看到的所请求资源的 index 的变化
`wait`:: 该值用于表示阻塞查询的最大时间。 该值最大为 10 分钟。

[source,java]
----
BlockingQueryOptions opts = new BlockingQueryOptions()
  .setIndex(lastIndex)
  .setWait("1m");
----

要注意的是，阻塞查询不能 *严格保证* 所返回的数据确实是发生了变化的。
很有可能的情况是，阻塞查询的返回只是因为超时时间到了或发生了并没有改变数据内容的写入。

== 键值对存储

键值对接口用于访问 Consul 内部的简单键值对存储，这对保存服务的配置或其他元数据很有用。
以下是可以使用的接口

* 管理单个键值对的更新，删除和获取，以及根据键的前缀匹配的同样操作
* 管理通过单个原子性的事务操作来获取和更新键值对的操作

=== 从存储中获取键值对

Consul 客户端可以返回一个键的值

[source,java]
----
consulClient.getValue("key", res -> {
  if (res.succeeded()) {
    System.out.println("retrieved value: " + res.result().getValue());
    System.out.println("modify index: " + res.result().getModifyIndex());
  } else {
    res.cause().printStackTrace();
  }
});
----

...或者返回所有匹配某一给定前缀的键的值

[source,java]
----
consulClient.getValues("prefix", res -> {
  if (res.succeeded()) {
    System.out.println("modify index: " + res.result().getIndex());
    for (KeyValue kv : res.result().getList()) {
      System.out.println("retrieved value: " + kv.getValue());
    }
  } else {
    res.cause().printStackTrace();
  }
});
----

返回的键值对数据包括以下字段 (参见 https://www.consul.io/docs/agent/http/kv.html#single[文档]):

`createIndex`:: 内部的创建索引，表示该键值对何时被创建的
`modifyIndex`:: 更新索引，该键值对最后一次被修改时的索引
`lockIndex`:: 该键被成功获取锁的次数
`key`:: 键
`flags`:: 该键值对的标志位。 客户端可以选择使用标识位
来表示应用业务中的一些信息
`value`:: 值
`session`:: 拥有锁的会话

更新索引可以用于阻塞查询：

[source,java]
----
BlockingQueryOptions opts = new BlockingQueryOptions()
  .setIndex(modifyIndex)
  .setWait("1m");

consulClient.getValueWithOptions("key", opts, res -> {
  if (res.succeeded()) {
    System.out.println("retrieved value: " + res.result().getValue());
    System.out.println("new modify index: " + res.result().getModifyIndex());
  } else {
    res.cause().printStackTrace();
  }
});
----

=== 保存键值对

[source,java]
----
consulClient.putValue("key", "value", res -> {
  if (res.succeeded()) {
    String opResult = res.result() ? "success" : "fail";
    System.out.println("result of the operation: " + opResult);
  } else {
    res.cause().printStackTrace();
  }
});
----

保存请求也可以接受参数

[source,java]
----
KeyValueOptions opts = new KeyValueOptions()
  .setFlags(42)
  .setCasIndex(modifyIndex)
  .setAcquireSession("acquireSessionID")
  .setReleaseSession("releaseSessionID");

consulClient.putValueWithOptions("key", "value", opts, res -> {
  if (res.succeeded()) {
    String opResult = res.result() ? "success" : "fail";
    System.out.println("result of the operation: " + opResult);
  } else {
    res.cause().printStackTrace();
  }
});
----

以下是 `PUT` 请求可以接收的参数

`flags`:: 可以指定一个无符号数，范围是 `0` 到 `2^64^-1` 
客户端可以选择使用标识位来表示应用业务中的一些信息
`casIndex`:: 该标志位用于将 PUT 操作转为一次检查设置（Check-And-Set）操作。 如果你需要构建一个
拥有非常复杂同步原语的操作的话这回非常有用。 如果该索引值为 `0`， Consul 只会在键不存在的情况下
设置该键值对。 如果该索引不为 0， 该键值对只会在该索引与更新索引相匹配的时候被设置。
`acquireSession`:: 该标志位用于将 PUT 操作转为一次需要获取锁的操作。 这个参数可以让
Consul 在顶层发生领导选举。 如果锁未被获取并且会话有效，
那么该操作会增加锁索引（LockIndex） 并设置该键值对所属的会话以更新该键的值。
获取锁时键不一定存在。 如果锁已经被设置的会话持有， 那么锁索引
不会增加，但是键的内容还是会更新。 这是因为该会话当前已经拥有锁，可以直接更新键的内容，
而不用再释放锁并重新获取
`releaseSession`:: 该标志位用于将 PUT 操作转换为一次释放锁的操作。 跟 `acquireSession` 一起搭配
使用的话会很有用，这样可以让客户端生成一个锁。 该操作不会修改锁索引，但会释放
与该键相关联的会话。 前提是该键的锁正在被该会话持有。

=== 事务

当连接到 Consul 的 0.7 或更高的版本时， 客户端可以使用单次原子性的事务操作
来管理对多个键的更新和查询。 事务操作目前只支持键值对， 其他类型的
事务操作可能会在以后的版本中支持。
(参见 https://www.consul.io/docs/agent/http/kv.html#txn[文档]).

[source,java]
----
TxnRequest request = new TxnRequest()
  .addOperation(new TxnKVOperation().setKey("key1").setValue("value1").setType(TxnKVVerb.SET))
  .addOperation(new TxnKVOperation().setKey("key2").setValue("value2").setType(TxnKVVerb.SET));

consulClient.transaction(request, res -> {
  if (res.succeeded()) {
    System.out.println("succeeded results: " + res.result().getResults().size());
    System.out.println("errors: " + res.result().getErrors().size());
  } else {
    res.cause().printStackTrace();
  }
});
----

=== 删除键值对

最后， Consul 允许你从存储中删除键值对

[source,java]
----
consulClient.deleteValue("key", res -> {
  if (res.succeeded()) {
    System.out.println("complete");
  } else {
    res.cause().printStackTrace();
  }
});
----

...或者删除所有符合该前缀的键值对

[source,java]
----
consulClient.deleteValues("prefix", res -> {
  if (res.succeeded()) {
    System.out.println("complete");
  } else {
    res.cause().printStackTrace();
  }
});
----

== 服务

服务发现的主要目的之一是提供可用的服务清单。
为了实现该目标， agent 提供了一个简单的服务声明格式以便说明当前服务是否可用
并将它与健康检查潜在地关联起来。

=== 服务注册

服务的声明格式必须包含一个 `name` ，还可以选择设置 `id`， `tags`， `address`， `port`， 和 `checks` 等属性

[source,java]
----
ServiceOptions opts = new ServiceOptions()
  .setName("serviceName")
  .setId("serviceId")
  .setTags(Arrays.asList("tag1", "tag2"))
  .setCheckOptions(new CheckOptions().setTtl("10s"))
  .setAddress("10.0.0.1")
  .setPort(8048);
----

`name`:: 服务的名称
`id`:: 如果没有设置 `name` 则会使用 `id` 替代。 节点的每个服务都需要使用唯一的 ID，
如果 `name` 发生了冲突，那么会使用 `id` 替换。
`tags`:: 一组数据，对 Consul 来说没有意义，但是用于区分服务是不是主要节点或是次要节点
不同的版本，或者服务的其他不同等级标记
`address`:: 用于区分服务的 IP 地址。 默认情况下，使用 agent 的地址，
不需要手动设置
`port`:: 也是用于简要配置面向服务的结构； 这样，
通过配置的地址和端口可以发现一个服务
`checks`:: 关联的健康检查

这些设置用于将服务注册到清单中：

[source,java]
----
consulClient.registerService(opts, res -> {
  if (res.succeeded()) {
    System.out.println("Service successfully registered");
  } else {
    res.cause().printStackTrace();
  }

});
----

=== 服务发现

Consul 客户端可以当前可以提供服务的节点列表：

[source,java]
----
consulClient.catalogServiceNodes("serviceName", res -> {
  if (res.succeeded()) {
    System.out.println("found " + res.result().getList().size() + " services");
    System.out.println("consul state index: " + res.result().getIndex());
    for (Service service : res.result().getList()) {
      System.out.println("Service node: " + service.getNode());
      System.out.println("Service address: " + service.getAddress());
      System.out.println("Service port: " + service.getPort());
    }
  } else {
    res.cause().printStackTrace();
  }
});
----

获取节点列表时还可以同时获取相关联的健康检查的状态。
可以使用健康检查的状态过滤结果。

[source,java]
----
consulClient.healthServiceNodes("serviceName", passingOnly, res -> {
  if (res.succeeded()) {
    System.out.println("found " + res.result().getList().size() + " services");
    System.out.println("consul state index: " + res.result().getIndex());
    for (ServiceEntry entry : res.result().getList()) {
      System.out.println("Service node: " + entry.getNode());
      System.out.println("Service address: " + entry.getService().getAddress());
      System.out.println("Service port: " + entry.getService().getPort());
    }
  } else {
    res.cause().printStackTrace();
  }
});
----

查询服务时还可以设置以下参数：

[source,java]
----
ServiceQueryOptions queryOpts = new ServiceQueryOptions()
  .setTag("tag1")
  .setNear("_agent")
  .setBlockingOptions(new BlockingQueryOptions().setIndex(lastIndex));
----

`tag`:: 默认情况下，会返回所有匹配服务的节点。
你可以指定 `tag` 查询参数以根据服务的标签过滤返回结果
`near`:: 添加可选的 `near` 参数为一个节点名，那么返回结果会根据
到该节点的 rtt（round trip time，即往返时间）升序排序。 如果设置 `near`=`_agent` 那么会使用当前节点作为排序的依据。
`blockingOptions`:: 阻塞查询参数

请求如下所示：

[source,java]
----
consulClient.healthServiceNodesWithOptions("serviceName", passingOnly, queryOpts, res -> {
  if (res.succeeded()) {
    System.out.println("found " + res.result().getList().size() + " services");
  } else {
    res.cause().printStackTrace();
  }

});
----

=== 取消注册服务

服务可以通过它的 ID 取消注册：

[source,java]
----
consulClient.deregisterService("serviceId", res -> {
  if (res.succeeded()) {
    System.out.println("Service successfully deregistered");
  } else {
    res.cause().printStackTrace();
  }
});
----

== 健康检查

agent 的主要角色之一就是系统层面和应用层面上的健康检查管理。
如果健康检查与服务关联，那么该健康检查被认为是应用层面上的。
反之，则健康检查监控的是整个节点的健康状态。

[source,java]
----
CheckOptions opts = new CheckOptions()
  .setTcp("localhost:4848")
  .setInterval("1s");
----

以下是 Consul 客户端支持的健康检查选项：

`id`:: 健康检查 ID
`name`:: 健康检查名称
`script`:: 健康检查脚本的路径，同时你应该设置检查的间隔
`http`:: 健康检查的 HTTP 地址，同时你应该设置检查的间隔
`ttl`:: 健康检查的 ttl（time to live，即生存时间）
`tcp`:: 健康检查的 tcp 地址，同时你应该设置检查的间隔
`interval`:: 健康检查的时间间隔，使用 Go 语言的时间格式，是一个十进制的数组字符串，
可以携带小数和单位后缀，例如 "300ms"， "-1.5h" 或 "2h45m"
有效的时间单位是 "ns"， "us" （或 "µs"）， "ms"， "s"， "m"， "h"
`notes`:: 健康检查的备注
`serviceId`:: 服务的 ID，用于将当前注册的健康检查与 agent 提供的已存在的服务相关联
`deregisterAfter`:: 取消注册超时时间。 该设置是可选的， 它的时间格式与 Interval 和 TTL 相同。
如果健康检查与一个服务相关联并且服务的状态处于不可用的时间超过该值，
那么该服务 (以及所有该服务相关联的服务) 将会自动取消注册
该值最小为 1 分钟， 并且用于解除服务的进程每 30 秒运行一次。
因此实际运用中，Consul 可能会花费比该设置长一点的时间将服务取消注册。
该超时时间应该配置得远大于该服务
重启或恢复所需要得时间。
`status`:: 健康检查的初始状态值

`Name` 字段是必须的，而 `Script`， `HTTP`， `TCP` 或 `TTL` 只需一个就可以。 `Script`， `TCP` 和 `HTTP`
需要设置 `Interval` 选项。 如果没有提供 `ID` ， 会用 `Name` 的值替代。
每个节点上不能有重复的 ID， 因此设置一个 ID 是很有必要的。

[source,java]
----
consulClient.registerCheck(opts, res -> {
  if (res.succeeded()) {
    System.out.println("check successfully registered");
  } else {
    res.cause().printStackTrace();
  }
});
----

== Events

The Consul provides a mechanism to fire a custom user event to an entire datacenter.
These events are opaque to Consul, but they can be used to build scripting infrastructure to do automated deploys,
restart services, or perform any other orchestration action.

To send user event only its name is required

[source,java]
----
consulClient.fireEvent("eventName", res -> {
  if (res.succeeded()) {
    System.out.println("Event sent");
    System.out.println("id: " + res.result().getId());
  } else {
    res.cause().printStackTrace();
  }
});
----

Also additional options can be specified.

`node`:: regular expression to filter recipients by node name
`service`:: regular expression to filter recipients by service
`tag`:: regular expression to filter recipients by tag
`payload`:: an optional body of the event.
The body contents are opaque to Consul and become the "payload" of the event

[source,java]
----
EventOptions opts = new EventOptions()
  .setTag("tag")
  .setPayload("message");

consulClient.fireEventWithOptions("eventName", opts, res -> {
  if (res.succeeded()) {
    System.out.println("Event sent");
    System.out.println("id: " + res.result().getId());
  } else {
    res.cause().printStackTrace();
  }
});
----

The Consul Client supports queries for obtain the most recent events known by the agent. Events are broadcast using
the gossip protocol, so they have no global ordering nor do they make a promise of delivery. Agents only buffer
the most recent entries. The current buffer size is 256, but this value could change in the future.

[source,java]
----
consulClient.listEvents(res -> {
  if (res.succeeded()) {
    System.out.println("Consul index: " + res.result().getIndex());
    for(Event event: res.result().getList()) {
      System.out.println("Event id: " + event.getId());
      System.out.println("Event name: " + event.getName());
      System.out.println("Event payload: " + event.getPayload());
    }
  } else {
    res.cause().printStackTrace();
  }
});
----

The Consul Index can be used to prepare blocking requests:

[source,java]
----
EventListOptions opts = new EventListOptions()
  .setName("eventName")
  .setBlockingOptions(new BlockingQueryOptions().setIndex(lastIndex));

consulClient.listEventsWithOptions(opts, res -> {
  if (res.succeeded()) {
    System.out.println("Consul index: " + res.result().getIndex());
    for(Event event: res.result().getList()) {
      System.out.println("Event id: " + event.getId());
    }
  } else {
    res.cause().printStackTrace();
  }
});
----

== Sessions

Consul provides a session mechanism which can be used to build distributed locks.
Sessions act as a binding layer between nodes, health checks, and key/value data.
When a session is constructed, a node name, a list of health checks, a behavior, a TTL, and a lock-delay
may be provided.

[source,java]
----
SessionOptions opts = new SessionOptions()
  .setNode("nodeId")
  .setBehavior(SessionBehavior.RELEASE);
----

`lockDelay`:: can be specified as a duration string using an 's' suffix for seconds. The default is '15s'.
`name`:: can be used to provide a human-readable name for the Session.
`node`:: must refer to a node that is already registered, if specified. By default, the agent's own node name is used.
`checks`:: is used to provide a list of associated health checks. It is highly recommended that,
if you override this list, you include the default `serfHealth`.
`behavior`:: can be set to either `release` or `delete`. This controls the behavior when a session is invalidated.
By default, this is `release`, causing any locks that are held to be released. Changing this to `delete` causes
any locks that are held to be deleted. `delete` is useful for creating ephemeral key/value entries.
`ttl`:: is a duration string, and like `LockDelay` it can use s as a suffix for seconds. If specified,
it must be between 10s and 86400s currently. When provided, the session is invalidated if it is not renewed before the TTL expires.

For full info see https://www.consul.io/docs/internals/sessions.html[Consul Sessions internals]

The newly constructed session is provided with a named ID that can be used to identify it.
This ID can be used with the KV store to acquire locks: advisory mechanisms for mutual exclusion.

[source,java]
----
consulClient.createSessionWithOptions(opts, res -> {
  if (res.succeeded()) {
    System.out.println("Session successfully created");
    System.out.println("id: " + res.result());
  } else {
    res.cause().printStackTrace();
  }
});
----

And also to destroy it

[source,java]
----
consulClient.destroySession(sessionId, res -> {
  if (res.succeeded()) {
    System.out.println("Session successfully destroyed");
  } else {
    res.cause().printStackTrace();
  }
});
----

Lists sessions belonging to a node

[source,java]
----
consulClient.listNodeSessions("nodeId", res -> {
  if (res.succeeded()) {
    for(Session session: res.result().getList()) {
      System.out.println("Session id: " + session.getId());
      System.out.println("Session node: " + session.getNode());
      System.out.println("Session create index: " + session.getCreateIndex());
    }
  } else {
    res.cause().printStackTrace();
  }
});
----

All of the read session endpoints support blocking queries and all consistency modes.

[source,java]
----
BlockingQueryOptions blockingOpts = new BlockingQueryOptions()
  .setIndex(lastIndex);

consulClient.listSessionsWithOptions(blockingOpts, res -> {
  if (res.succeeded()) {
    System.out.println("Found " + res.result().getList().size() + " sessions");
  } else {
    res.cause().printStackTrace();
  }
});
----

== Nodes in datacenter

[source,java]
----
consulClient.catalogNodes(res -> {
  if (res.succeeded()) {
    System.out.println("found " + res.result().getList().size() + " nodes");
    System.out.println("consul state index " + res.result().getIndex());
  } else {
    res.cause().printStackTrace();
  }
});
----

This endpoint supports blocking queries and sorting by distance from specified node

[source,java]
----
NodeQueryOptions opts = new NodeQueryOptions()
  .setNear("_agent")
  .setBlockingOptions(new BlockingQueryOptions().setIndex(lastIndex));

consulClient.catalogNodesWithOptions(opts, res -> {
  if (res.succeeded()) {
    System.out.println("found " + res.result().getList().size() + " nodes");
  } else {
    res.cause().printStackTrace();
  }
});
----

== Prepared Queries

This endpoint creates, updates, destroys, and executes prepared queries.
Prepared queries allow you to register a complex service query and then execute it later via its ID
or name to get a set of healthy nodes that provide a given service. This is particularly useful in combination
with Consul's DNS Interface as it allows for much richer queries than would be possible given
the limited entry points exposed by DNS.

There are many parameters to creating a prepared query.
For full details please https://www.consul.io/api/query.html[see docs]

`dc` :: Specifies the datacenter to query. This will default to the datacenter of the agent being queried. This is specified as part of the URL as a query parameter.
`name` :: Specifies an optional friendly name that can be used to execute a query instead of using its ID.
`session` :: Specifies the ID of an existing session. This provides a way to automatically remove a prepared query when the given session is invalidated. If not given the prepared query must be manually removed when no longer needed.
`token` :: Specifies the ACL token to use each time the query is executed. This allows queries to be executed by clients with lesser or even no ACL Token, so this should be used with care. The token itself can only be seen by clients with a management token. If the Token field is left blank or omitted, the client's ACL Token will be used to determine if they have access to the service being queried. If the client does not supply an ACL Token, the anonymous token will be used.
`service` :: Specifies the name of the service to query. This is required field.
`failover` :: contains two fields, both of which are optional, and determine what happens if no healthy nodes are available in the local datacenter when the query is executed. It allows the use of nodes in other datacenters with very little configuration.
`nearestN` :: Specifies that the query will be forwarded to up to NearestN other datacenters based on their estimated network round trip time using Network Coordinates from the WAN gossip pool. The median round trip time from the server handling the query to the servers in the remote datacenter is used to determine the priority.
`datacenters` :: Specifies a fixed list of remote datacenters to forward the query to if there are no healthy nodes in the local datacenter. Datacenters are queried in the order given in the list. If this option is combined with NearestN, then the NearestN queries will be performed first, followed by the list given by Datacenters. A given datacenter will only be queried one time during a failover, even if it is selected by both NearestN and is listed in Datacenters.
`onlyPassing` :: Specifies the behavior of the query's health check filtering. If this is set to false, the results will include nodes with checks in the passing as well as the warning states. If this is set to true, only nodes with checks in the passing state will be returned.
`tags` :: Specifies a list of service tags to filter the query results. For a service to pass the tag filter it must have all of the required tags, and none of the excluded tags (prefixed with !).
`nodeMeta` :: Specifies a list of user-defined key/value pairs that will be used for filtering the query results to nodes with the given metadata values present.
`dnsTtl` :: Specifies the TTL duration when query results are served over DNS. If this is specified, it will take precedence over any Consul agent-specific configuration.
`templateType` :: is the query type, which must be `name_prefix_match`. This means that the template will apply to any query lookup with a name whose prefix matches the Name field of the template. In this example, any query for geo-db will match this query. Query templates are resolved using a longest prefix match, so it's possible to have high-level templates that are overridden for specific services. Static queries are always resolved first, so they can also override templates.
`templateRegexp` :: is an optional regular expression which is used to extract fields from the entire name, once this template is selected. In this example, the regular expression takes the first item after the "-" as the database name and everything else after as a tag. See the RE2 reference for syntax of this regular expression.

[source,java]
----
PreparedQueryDefinition def = new PreparedQueryDefinition()
  .setName("Query name")
  .setService("service-${match(1)}-${match(2)}")
  .setDcs(Arrays.asList("dc1", "dc42"))
  .setTemplateType("name_prefix_match")
  .setTemplateRegexp("^find_(.+?)_(.+?)$");
----

If the query is successfully created, its ID will be provided

[source,java]
----
consulClient.createPreparedQuery(def, res -> {
  if (res.succeeded()) {
    String queryId = res.result();
    System.out.println("Query created: " + queryId);
  } else {
    res.cause().printStackTrace();
  }
});
----

The prepared query can be executed by its id

[source,java]
----
consulClient.executePreparedQuery(id, res -> {
  if (res.succeeded()) {
    PreparedQueryExecuteResponse response = res.result();
    System.out.println("Found " + response.getNodes().size() + " nodes");
  } else {
    res.cause().printStackTrace();
  }
});
----

or by query string that must match template regexp

[source,java]
----
consulClient.executePreparedQuery("find_1_2", res -> {
  // matches template regexp "^find_(.+?)_(.+?)$"
  if (res.succeeded()) {
    PreparedQueryExecuteResponse response = res.result();
    System.out.println("Found " + response.getNodes().size() + " nodes");
  } else {
    res.cause().printStackTrace();
  }
});
----

Finally, `ConsulClient` allows you to modify, get or delete prepared queries

[source,java]
----
consulClient.deletePreparedQuery(query, res -> {
  if (res.succeeded()) {
    System.out.println("Query deleted");
  } else {
    res.cause().printStackTrace();
  }
});
----

== Watches

Watches are a way of specifying a view of data (e.g. list of nodes, KV pairs, health checks)
which is monitored for updates. When an update is detected, an `Handler` with `WatchResult` is invoked.
As an example, you could watch the status of health checks and notify when a check is critical.

[source,java]
----
Watch.key("foo/bar", vertx)
  .setHandler(res -> {
    if (res.succeeded()) {
      System.out.println("value: " + res.nextResult().getValue());
    } else {
      res.cause().printStackTrace();
    }
  })
  .start();
----