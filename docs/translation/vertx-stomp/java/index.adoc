= Vert.x-Stomp
:toc: left

STOMP is the Simple (or Streaming) Text Orientated Messaging Protocol. STOMP
provides an interoperable wire format so that STOMP clients can communicate with any STOMP message broker to
provide easy and widespread messaging interoperability among many languages, platforms and brokers. Get more details about STOMP on https://stomp.github.io/index.html.

Vertx-Stomp is an implementation of a STOMP server and client. You can use the STOMP server with other clients and
use the STOMP client with other servers. The server and the client supports the version 1.0, 1.1 and 1.2 of the
STOMP protocol (see https://stomp.github.io/stomp-specification-1.2.html). The STOMP server can also be used as a
bridge with the vert.x event bus, or directly with web sockets (using StompJS).

== 使用 vertx-stomp

为了使用 Vert.x Stomp 服务端和客户端, 需要将以下依赖项添加到你的项目构建描述文件
的 _依赖配置_ 中:

* Maven (在您的 `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-stomp</artifactId>
 <version>4.0.3</version>
</dependency>
----

* Gradle (在您的 `build.gradle` 文件中):

[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-stomp:4.0.3'
----

== STOMP 服务器

=== 创建 STOMP 服务器

以下是使用默认的配置去创建 STOMP 服务器的最简单的方法:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx))
    .listen();
----

This creates a STOMP server listening on `localhost:61613` that is compliant with the STOMP specification.

你可以使用 `link:../../apidocs/io/vertx/ext/stomp/StompServer.html#listen-int-java.lang.String-[listen]` 方法
去配置服务器监听的主机地址和端口:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx))
    .listen(1234, "0.0.0.0");
----

如果你设置端口号为 `-1` , TCP 服务器将无法启动。 如果你使用到了 Websocket 桥接
这回很有用。 使用以下方式设置回调，以便在服务器就绪时收到通知:

[source,java]
----
StompServer server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx))
    .listen(ar -> {
      if (ar.failed()) {
        System.out.println("Failing to start the STOMP server : " + ar.cause().getMessage());
      } else {
        System.out.println("Ready to receive STOMP frames");
      }
    });
----

该回调接收一个类型是 `link:../../apidocs/io/vertx/ext/stomp/StompServer.html[StompServer]` 的引用参数。

你也可以使用 `link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html[StompServerOptions]` 配置服务器监听的主机地址和端口:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx, new StompServerOptions().setPort(1234).setHost("0.0.0.0"))
    .handler(StompServerHandler.create(vertx))
    .listen();
----

=== 关闭 STOMP 服务器

使用如下方式关闭 STOMP 服务器:

[source,java]
----
server.close(ar -> {
  if (ar.succeeded()) {
    System.out.println("The STOMP server has been closed");
  } else {
    System.out.println("The STOMP server failed to close : " + ar.cause().getMessage());
  }
});
----

=== 配置

使用 `link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html[StompServerOptions]` 配置 STOMP 服务器的参数

首先，STOMP 服务器是基于
`link:../../apidocs/io/vertx/core/net/NetServer.html[NetServer]` 的， 因此你可以在  `link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html[StompServerOptions]` 中配置
底层使用的 `link:../../apidocs/io/vertx/core/net/NetServer.html[NetServer]`。或者你可以将
你想要使用的 `link:../../apidocs/io/vertx/core/net/NetServer.html[NetServer]` 实例作为参数传入:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx, netServer)
    .handler(StompServerHandler.create(vertx))
    .listen();
----

该配置类 `link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html[StompServerOptions]` 可以让你设置以下选项：

* STOMP 服务器默认监听的主机地址和端口 - 默认为 `0.0.0.0:61613`.
* STOMP 服务器是否使用安全验证 - 默认为 `false`
* STOMP 协议消息体的最大尺寸限制 - 默认为 10 Mb
* STOMP 协议消息体的最大首部限制 - 默认为 1000
* STOMP 协议消息体中首部行长度的最大限制 - 默认为 10240
* STOMP 协议的心跳时间 - 默认为 `1000, 1000`
* 支持的 STOMP 协议版本 (默认为 1.0, 1.1 和 1.2)
* STOMP 协议中事务所支持的最大帧数量 (默认为 1000)
* 分块传输的最大尺寸 - 默认为 1000 (参见
`link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html#setTransactionChunkSize-int-[setTransactionChunkSize]`)
* 一个客户端可以使用的最大订阅数量 - 默认为 1000

如下所示，使用 JsonObject 配置 STOMP 协议的心跳：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx, new StompServerOptions().setHeartbeat(
    new JsonObject().put("x", 1000).put("y", 1000)))
    .handler(StompServerHandler.create(vertx))
    .listen();
----

要使用安全认证功能，需要提供 `link:../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html[AuthenticationProvider]` 以处理
认证请求：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx, new StompServerOptions().setSecured(true))
    .handler(StompServerHandler.create(vertx).authProvider(provider))
    .listen();
----

更多关于 `link:../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html[AuthenticationProvider]` 的信息请参考
http://vertx.io/docs/#authentication_and_authorisation[此文档].

如果一个帧的大小超过了限制, 那么它会被拒绝接收，并且客户端会收到一个 `ERROR` 帧。 按照协议
要求，在发送这种错误数据后，客户端需要立即关闭。 如果发送的数据不符合其他
阈值的要求，客户端也需要立即关闭。

=== 订阅

默认的 STOMP 服务器将订阅作为普通的字符串处理。 因此它不能对订阅主题进行解析
和分级。 默认的 STOMP 服务器遵循 _topic_ 语义。(因此消息会被分发给所有
对应的订阅客户端)。

=== 消息目的地类型

默认情况下， STOMP 服务器将消息发送的 _目的地_ 作为主题处理。 因此消息会被发送给所有的订阅者。 你可以
配置 STOMP 服务器将消息发送的目的地作为队列处理, 或两种模式都支持：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .destinationFactory((v, name) -> {
          if (name.startsWith("/queue")) {
            return Destination.queue(vertx, name);
          } else {
            return Destination.topic(vertx, name);
          }
        }))
    .listen();
----

在上一个例子中， 所有以 `/queue` 开头的目的地均被作为队列处理，而其他的目的地被当作主题类型。 目的地是在 STOMP 服务器
第一次接收到对应的订阅消息时被创建的。

STOMP 服务器通过返回 `null` 以拒绝目的地的创建：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .destinationFactory((v, name) -> {
          if (name.startsWith("/forbidden")) {
            return null;
          } else if (name.startsWith("/queue")) {
            return Destination.queue(vertx, name);
          } else {
            return Destination.topic(vertx, name);
          }
        }))
    .listen();
----

在这种情况下， 订阅客户端会收到一个 `ERROR` 帧。

队列类型的目的地使用轮询调度策略向订阅者分发消息

=== 提供你自定义的目的地类型

Vert.x 提供的 STOMP 有意没有实现任何高级特性。 如果你需要更加高级的消息分发策略，
可以提供自定义的 `link:../../apidocs/io/vertx/ext/stomp/DestinationFactory.html[DestinationFactory]` 实现
以返回你自己的 `link:../../apidocs/io/vertx/ext/stomp/Destination.html[Destination]` 类型实例。

=== 确认消息

默认情况下， STOMP 服务器如果没有收到一个消息的确认消息不会做任何处理。 你可以通过提供你自定义的
 `link:../../apidocs/io/vertx/ext/stomp/Destination.html[Destination]` 以实现对确认消息的处理

自定义的 destination 应该实现

`link:../../apidocs/io/vertx/ext/stomp/StompServerHandler.html#onAck-io.vertx.ext.stomp.StompServerConnection-io.vertx.ext.stomp.Frame-java.util.List-[onAck]`
和
`link:../../apidocs/io/vertx/ext/stomp/StompServerHandler.html#onNack-io.vertx.ext.stomp.StompServerConnection-io.vertx.ext.stomp.Frame-java.util.List-[onNack]`
方法以供 `link:../../apidocs/io/vertx/ext/stomp/StompServerHandler.html[StompServerHandler]` 实现特定的动作：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .onAckHandler(acknowledgement -> {
          // Action to execute when the frames (one in `client-individual` mode, several
          // in `client` mode are acknowledged.
        })
        .onNackHandler(acknowledgement -> {
          // Action to execute when the frames (1 in `client-individual` mode, several in
          // `client` mode are not acknowledged.
        }))
    .listen();
----

=== 配置 STOMP 服务器

除了上文所述的回调, 你还可以配置 STOMP 服务器的几乎所有配置, 例如收到
指定消息类型的响应动作, 发送给客户端的 `ping` 消息 (为了实现心跳)。
以下是示例

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
            .closeHandler(connection -> {
              // 客户端关闭的回调
            })
            .beginHandler(frame -> {
              // 开始传输事务的回调
            })
            .commitHandler(frame -> {
                  // 传输事务完成的回调
                }
            )
        //...
    ).listen();
----

注意改变默认的动作实现可能会导致对 STOMP 协议标准的破坏。 所以请参考
默认的实现。

== STOMP client

STOMP clients connect to STOMP server and can send and receive frames.

=== Creating a STOMP client

You create a `link:../../apidocs/io/vertx/ext/stomp/StompClient.html[StompClient]` instance with default options as follows:

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    // use the connection
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

The previous snippet creates a STOMP client connecting to "0.0.0.0:61613". Once connected, you get a
`link:../../apidocs/io/vertx/ext/stomp/StompClientConnection.html[StompClientConnection]` that let you interact with the server. You can
configure the host and port as follows:

[source,java]
----
StompClient.create(vertx)
  .connect(61613, "0.0.0.0")
  .onSuccess(connection -> {
    // use the connection
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

To catch connection errors due to authentication issues, or whatever error frames sent by the server during
the connection negotiation, you can register a _error handler_ on the Stomp Client. All
connections created with the client inherit of the error handler (but can have their own):

[source,java]
----
StompClient.create(vertx)
  .errorFrameHandler(frame -> {
    // Received the ERROR frame
  })
  .connect(61613, "0.0.0.0")
  .onSuccess(connection -> {
    // use the connection
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

You can also configure the host and port in the `link:../../apidocs/io/vertx/ext/stomp/StompClientOptions.html[StompClientOptions]`:

[source,java]
----
StompClient
  .create(vertx, new StompClientOptions().setHost("localhost").setPort(1234))
  .connect()
  .onSuccess(connection -> {
    // use the connection
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== Closing a STOMP client

You can close a STOMP client:

[source,java]
----
StompClient client = StompClient
  .create(vertx, new StompClientOptions().setHost("localhost").setPort(1234));

client
  .connect()
  .onSuccess(connection -> {
    // use the connection
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));

client.close();
----

However, this way would not notify the server of the disconnection. To cleanly close the connection, you should
use the `link:../../apidocs/io/vertx/ext/stomp/StompClientConnection.html#disconnect--[disconnect]` method:

[source,java]
----
StompClient
  .create(vertx, new StompClientOptions().setHost("localhost").setPort(1234))
  .connect()
  .onSuccess(connection -> {
    // use the connection
    connection.disconnect();
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

If the heartbeat is enabled and if the client did not detect server activity after the configured timeout, the
connection is automatically closed.

=== Handling errors

On the `link:../../apidocs/io/vertx/ext/stomp/StompClientConnection.html[StompClientConnection]`, you can register an error handler receiving `ERROR`
frames sent by the server. Notice that the server closes the connection with the client after having sent such frame:

[source,java]
----
StompClient
  .create(vertx, new StompClientOptions().setHost("localhost").setPort(1234))
  .connect()
  .onSuccess(connection -> {
    // use the connection
    connection
      .errorHandler(frame ->
        System.out.println("ERROR frame received : " + frame));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

The client can also be notified when a connection drop has been detected. Connection failures are detected using the
STOMP heartbeat mechanism. When the server has not sent a message in the heartbeat time window, the connection is
closed and the `connectionDroppedHandler` is called (if set). To configure a `connectionDroppedHandler`, call
`link:../../apidocs/io/vertx/ext/stomp/StompClientConnection.html#connectionDroppedHandler-io.vertx.core.Handler-[connectionDroppedHandler]`. The handler can
for instance tries to reconnect to the server:

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {

    connection.connectionDroppedHandler(con -> {
      // The connection has been lost
      // You can reconnect or switch to another server.
    });

    connection.send("/queue", Buffer.buffer("Hello"))
      .onSuccess(frame -> System.out.println("Message processed by the server")
      );
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== Configuration

You can configure various aspect by passing a
`link:../../apidocs/io/vertx/ext/stomp/StompClientOptions.html[StompClientOptions]` when creating the `link:../../apidocs/io/vertx/ext/stomp/StompClient.html[StompClient]`. As the
STOMP client relies on a `link:../../apidocs/io/vertx/core/net/NetClient.html[NetClient]`, you can configure the underlying Net Client from
the `link:../../apidocs/io/vertx/ext/stomp/StompClientOptions.html[StompClientOptions]`. Alternatively, you can pass the `link:../../apidocs/io/vertx/core/net/NetClient.html[NetClient]`
you want to use in the
`link:../../apidocs/io/vertx/ext/stomp/StompClient.html#connect-io.vertx.core.net.NetClient-io.vertx.core.Handler-[connect]` method:

[source,java]
----
StompClient.create(vertx)
  .connect(netClient)
  .onSuccess(connection -> {
    // use the connection
    connection
      .errorHandler(frame ->
        System.out.println("ERROR frame received : " + frame));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

The `link:../../apidocs/io/vertx/ext/stomp/StompClientOptions.html[StompClientOptions]` let you configure:

* the host and port ot the STOMP server
* the login and passcode to connect to the server
* whether or not the `content-length` header should be added to the frame if not set explicitly. (enabled by default)
* whether or not the `STOMP` command should be used instead of the `CONNECT` command (disabled by default)
* whether or not the `host` header should be ignored in the `CONNECT` frame (disabled by default)
* the heartbeat configuration (1000, 1000 by default)

=== Subscribing to destinations

To subscribe to a destination, use:

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    // use the connection
    connection.subscribe("/queue", frame ->
      System.out.println("Just received a frame from /queue : " + frame));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

To unsubscribe, use:

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    // use the connection
    connection.subscribe("/queue", frame ->
      System.out.println("Just received a frame from /queue : " + frame));

    // ....

    connection.unsubscribe("/queue");
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== Sending messages

To send a message, use:

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    Map<String, String> headers = new HashMap<>();
    headers.put("header1", "value1");
    connection.send("/queue", headers, Buffer.buffer("Hello"));
    // No headers:
    connection.send("/queue", Buffer.buffer("World"));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

In Java and Groovy, you can use the `link:../../apidocs/io/vertx/ext/stomp/utils/Headers.html[Headers]` class to ease the header creation.


=== Acknowledgements

Clients can send `ACK` and `NACK` frames:

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    connection.subscribe("/queue", frame -> {
      connection.ack(frame.getAck());
      // OR
      connection.nack(frame.getAck());
    });
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== Transactions

Clients can also create transactions. `ACK`, `NACK` and `SEND` frames sent in the transaction will be delivery
only when the transaction is committed.

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    Map<String, String> headers = new HashMap<>();
    headers.put("transaction", "my-transaction");
    connection.beginTX("my-transaction");
    connection.send("/queue", headers, Buffer.buffer("Hello"));
    connection.send("/queue", headers, Buffer.buffer("World"));
    connection.send("/queue", headers, Buffer.buffer("!!!"));
    connection.commit("my-transaction");
    // OR
    connection.abort("my-transaction");
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== Receipt

Each sent commands can have a _receipt_ handler, notified when the server has processed the message:

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    connection
      .send("/queue", Buffer.buffer("Hello"))
      .onSuccess(frame ->
        System.out.println("Message processed by the server"));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

== Using the STOMP server as a bridge to the vert.x Event Bus

The STOMP server can be used as a bridge to the vert.x Event Bus. The bridge is bi-directional meaning the STOMP
frames are translated to Event Bus messages and Event Bus messages are translated to STOMP frames.

To enable the bridge you need to configure the inbound and outbound addresses. Inbound addresses are STOMP
destination that are transferred to the event bus. The STOMP destination is used as the event bus address. Outbound
addresses are event bus addresses that are transferred to STOMP.

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .bridge(new BridgeOptions()
            .addInboundPermitted(new PermittedOptions().setAddress("/toBus"))
            .addOutboundPermitted(new PermittedOptions().setAddress("/toStomp"))
        )
    )
    .listen();
----

By default, the bridge use a publish/subscribe delivery (topic). You can configure it to use a point to point
delivery where only one STOMP client or Event Bus consumer is invoked:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
            .bridge(new BridgeOptions()
                    .addInboundPermitted(new PermittedOptions().setAddress("/toBus"))
                    .addOutboundPermitted(new PermittedOptions().setAddress("/toStomp"))
                    .setPointToPoint(true)
            )
    )
    .listen();
----

The permitted options can also be expressed as a "regex" or with a _match_. A _match_ is a structure that the
message payload must meet. For instance, in the next examples, the payload must contains the field "foo" set to
"bar". Structure match only supports JSON object.

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .bridge(new BridgeOptions()
            .addInboundPermitted(new PermittedOptions().setAddress("/toBus")
                .setMatch(new JsonObject().put("foo", "bar")))
            .addOutboundPermitted(new PermittedOptions().setAddress("/toStomp"))
            .setPointToPoint(true)
        )
    )
    .listen();
----

== Using the STOMP server with web sockets

If you want to connect a JavaScript client (node.js or a browser) directly with the STOMP server, you can use a
web socket. The STOMP protocol has been adapted to work over web sockets in
http://jmesnil.net/stomp-websocket/doc/[StompJS]. The JavaScript connects directly to the STOMP server and send
STOMP frames on the web socket. It also receives the STOMP frame directly on the web socket.

To configure the server to use StompJS, you need to:

1. Enable the web socket bridge and configure the path of the listening web socket (`/stomp` by default).
2. Import http://jmesnil.net/stomp-websocket/doc/#download[StompJS] in your application (as a script on an
HTML page, or as an npm module (https://www.npmjs.com/package/stompjs).
3. Connect to the server

To achieve the first step, you would need a HTTP server, and pass the
`link:../../apidocs/io/vertx/ext/stomp/StompServer.html#webSocketHandler--[webSocketHandler]` result to
`link:../../apidocs/io/vertx/core/http/HttpServer.html#webSocketHandler-io.vertx.core.Handler-[webSocketHandler]`:

[source,java]
----
StompServer server = StompServer.create(vertx, new StompServerOptions()
    .setPort(-1) // Disable the TCP port, optional
    .setWebsocketBridge(true) // Enable the web socket support
    .setWebsocketPath("/stomp")) // Configure the web socket path, /stomp by default
    .handler(StompServerHandler.create(vertx));

Future<HttpServer> http = vertx.createHttpServer(
    new HttpServerOptions().setWebSocketSubProtocols(Arrays.asList("v10.stomp", "v11.stomp"))
)
    .webSocketHandler(server.webSocketHandler())
    .listen(8080);
----

Don't forget to declare the supported sub-protocols. Without this, the connection will be rejected.

Then follow the instructions from  http://jmesnil.net/stomp-websocket/doc/[the StompJS documentation] to connect to
the server. Here is a simple example:

[source, javascript]
----
var url = "ws://localhost:8080/stomp";
var client = Stomp.client(url);
var callback = function(frame) {
  console.log(frame);
};

client.connect({}, function() {
var subscription = client.subscribe("foo", callback);
});
----

== Registering received and writing frame handlers

STOMP clients, client's connections and server handlers support registering a received
`link:../../apidocs/io/vertx/ext/stomp/Frame.html[Frame]` handler that would be notified every time a frame is received from the wire. It lets
you log the frames, or implement custom behavior. The handler is already called for `PING`
frames, and _illegal / unknown_ frames:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx).receivedFrameHandler(sf -> {
      System.out.println(sf.frame());
    }))
    .listen();

StompClient client = StompClient.create(vertx).receivedFrameHandler(frame -> System.out.println(frame));
----

The handler is called before the frame is processed, so you can also _modify_ the frame.

Frames not using a valid STOMP command use the `UNKNOWN` command. The original command is written
in the headers using the `link:../../apidocs/io/vertx/ext/stomp/Frame.html#STOMP_FRAME_COMMAND[Frame.STOMP_FRAME_COMMAND]` key.

You can also register a handler to be notified when a frame is going to be sent (written to the wire):

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx))
    .writingFrameHandler(sf -> {
      System.out.println(sf.frame());
    })
    .listen();

StompClient client = StompClient.create(vertx).writingFrameHandler(frame -> {
  System.out.println(frame);
});
----