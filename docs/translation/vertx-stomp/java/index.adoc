= Vert.x-Stomp
:toc: left

STOMP is the Simple (or Streaming) Text Orientated Messaging Protocol. STOMP
provides an interoperable wire format so that STOMP clients can communicate with any STOMP message broker to
provide easy and widespread messaging interoperability among many languages, platforms and brokers. Get more details about STOMP on https://stomp.github.io/index.html.

Vertx-Stomp is an implementation of a STOMP server and client. You can use the STOMP server with other clients and
use the STOMP client with other servers. The server and the client supports the version 1.0, 1.1 and 1.2 of the
STOMP protocol (see https://stomp.github.io/stomp-specification-1.2.html). The STOMP server can also be used as a
bridge with the vert.x event bus, or directly with web sockets (using StompJS).

== 使用 vertx-stomp

为了使用 Vert.x Stomp 服务端和客户端, 需要将以下依赖项添加到你的项目构建描述文件
的 _依赖配置_ 中:

* Maven (在您的 `pom.xml`):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-stomp</artifactId>
 <version>4.0.3</version>
</dependency>
----

* Gradle (在您的 `build.gradle` 文件中):

[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-stomp:4.0.3'
----

== STOMP 服务器

=== 创建 STOMP 服务器

以下是使用默认的配置去创建 STOMP 服务器的最简单的方法:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx))
    .listen();
----

This creates a STOMP server listening on `localhost:61613` that is compliant with the STOMP specification.

你可以使用 `link:../../apidocs/io/vertx/ext/stomp/StompServer.html#listen-int-java.lang.String-[listen]` 方法
去配置服务器监听的主机地址和端口:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx))
    .listen(1234, "0.0.0.0");
----

如果你设置端口号为 `-1` , TCP 服务器将无法启动。 如果你使用到了 Websocket 桥接
这回很有用。 使用以下方式设置回调，以便在服务器就绪时收到通知:

[source,java]
----
StompServer server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx))
    .listen(ar -> {
      if (ar.failed()) {
        System.out.println("Failing to start the STOMP server : " + ar.cause().getMessage());
      } else {
        System.out.println("Ready to receive STOMP frames");
      }
    });
----

该回调接收一个类型是 `link:../../apidocs/io/vertx/ext/stomp/StompServer.html[StompServer]` 的引用参数。

你也可以使用 `link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html[StompServerOptions]` 配置服务器监听的主机地址和端口:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx, new StompServerOptions().setPort(1234).setHost("0.0.0.0"))
    .handler(StompServerHandler.create(vertx))
    .listen();
----

=== 关闭 STOMP 服务器

使用如下方式关闭 STOMP 服务器:

[source,java]
----
server.close(ar -> {
  if (ar.succeeded()) {
    System.out.println("The STOMP server has been closed");
  } else {
    System.out.println("The STOMP server failed to close : " + ar.cause().getMessage());
  }
});
----

=== 配置

使用 `link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html[StompServerOptions]` 配置 STOMP 服务器的参数

首先，STOMP 服务器是基于
`link:../../apidocs/io/vertx/core/net/NetServer.html[NetServer]` 的， 因此你可以在  `link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html[StompServerOptions]` 中配置
底层使用的 `link:../../apidocs/io/vertx/core/net/NetServer.html[NetServer]`。或者你可以将
你想要使用的 `link:../../apidocs/io/vertx/core/net/NetServer.html[NetServer]` 实例作为参数传入:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx, netServer)
    .handler(StompServerHandler.create(vertx))
    .listen();
----

该配置类 `link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html[StompServerOptions]` 可以让你设置以下选项：

* STOMP 服务器默认监听的主机地址和端口 - 默认为 `0.0.0.0:61613`.
* STOMP 服务器是否使用安全验证 - 默认为 `false`
* STOMP 协议消息体的最大尺寸限制 - 默认为 10 Mb
* STOMP 协议消息体的最大首部限制 - 默认为 1000
* STOMP 协议消息体中首部行长度的最大限制 - 默认为 10240
* STOMP 协议的心跳时间 - 默认为 `1000, 1000`
* 支持的 STOMP 协议版本 (默认为 1.0, 1.1 和 1.2)
* STOMP 协议中事务所支持的最大帧数量 (默认为 1000)
* 分块传输的最大尺寸 - 默认为 1000 (参见
`link:../../apidocs/io/vertx/ext/stomp/StompServerOptions.html#setTransactionChunkSize-int-[setTransactionChunkSize]`)
* 一个客户端可以使用的最大订阅数量 - 默认为 1000

如下所示，使用 JsonObject 配置 STOMP 协议的心跳：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx, new StompServerOptions().setHeartbeat(
    new JsonObject().put("x", 1000).put("y", 1000)))
    .handler(StompServerHandler.create(vertx))
    .listen();
----

要使用安全认证功能，需要提供 `link:../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html[AuthenticationProvider]` 以处理
认证请求：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx, new StompServerOptions().setSecured(true))
    .handler(StompServerHandler.create(vertx).authProvider(provider))
    .listen();
----

更多关于 `link:../../apidocs/io/vertx/ext/auth/authentication/AuthenticationProvider.html[AuthenticationProvider]` 的信息请参考
http://vertx.io/docs/#authentication_and_authorisation[此文档].

如果一个帧的大小超过了限制, 那么它会被拒绝接收，并且客户端会收到一个 `ERROR` 帧。 按照协议
要求，在发送这种错误数据后，客户端需要立即关闭。 如果发送的数据不符合其他
阈值的要求，客户端也需要立即关闭。

=== 订阅

默认的 STOMP 服务器将订阅作为普通的字符串处理。 因此它不能对订阅主题进行解析
和分级。 默认的 STOMP 服务器遵循 _topic_ 语义。(因此消息会被分发给所有
对应的订阅客户端)。

=== 消息目的地类型

默认情况下， STOMP 服务器将消息发送的 _目的地_ 作为主题处理。 因此消息会被发送给所有的订阅者。 你可以
配置 STOMP 服务器将消息发送的目的地作为队列处理, 或两种模式都支持：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .destinationFactory((v, name) -> {
          if (name.startsWith("/queue")) {
            return Destination.queue(vertx, name);
          } else {
            return Destination.topic(vertx, name);
          }
        }))
    .listen();
----

在上一个例子中， 所有以 `/queue` 开头的目的地均被作为队列处理，而其他的目的地被当作主题类型。 目的地是在 STOMP 服务器
第一次接收到对应的订阅消息时被创建的。

STOMP 服务器通过返回 `null` 以拒绝目的地的创建：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .destinationFactory((v, name) -> {
          if (name.startsWith("/forbidden")) {
            return null;
          } else if (name.startsWith("/queue")) {
            return Destination.queue(vertx, name);
          } else {
            return Destination.topic(vertx, name);
          }
        }))
    .listen();
----

在这种情况下， 订阅客户端会收到一个 `ERROR` 帧。

队列类型的目的地使用轮询调度策略向订阅者分发消息

=== 提供你自定义的目的地类型

Vert.x 提供的 STOMP 有意没有实现任何高级特性。 如果你需要更加高级的消息分发策略，
可以提供自定义的 `link:../../apidocs/io/vertx/ext/stomp/DestinationFactory.html[DestinationFactory]` 实现
以返回你自己的 `link:../../apidocs/io/vertx/ext/stomp/Destination.html[Destination]` 类型实例。

=== 确认消息

默认情况下， STOMP 服务器如果没有收到一个消息的确认消息不会做任何处理。 你可以通过提供你自定义的
 `link:../../apidocs/io/vertx/ext/stomp/Destination.html[Destination]` 以实现对确认消息的处理

自定义的 destination 应该实现

`link:../../apidocs/io/vertx/ext/stomp/StompServerHandler.html#onAck-io.vertx.ext.stomp.StompServerConnection-io.vertx.ext.stomp.Frame-java.util.List-[onAck]`
和
`link:../../apidocs/io/vertx/ext/stomp/StompServerHandler.html#onNack-io.vertx.ext.stomp.StompServerConnection-io.vertx.ext.stomp.Frame-java.util.List-[onNack]`
方法以供 `link:../../apidocs/io/vertx/ext/stomp/StompServerHandler.html[StompServerHandler]` 实现特定的动作：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .onAckHandler(acknowledgement -> {
          // Action to execute when the frames (one in `client-individual` mode, several
          // in `client` mode are acknowledged.
        })
        .onNackHandler(acknowledgement -> {
          // Action to execute when the frames (1 in `client-individual` mode, several in
          // `client` mode are not acknowledged.
        }))
    .listen();
----

=== 配置 STOMP 服务器

除了上文所述的回调, 你还可以配置 STOMP 服务器的几乎所有配置, 例如收到
指定消息类型的响应动作, 发送给客户端的 `ping` 消息 (为了实现心跳)。
以下是示例

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
            .closeHandler(connection -> {
              // 客户端关闭的回调
            })
            .beginHandler(frame -> {
              // 开始传输事务的回调
            })
            .commitHandler(frame -> {
                  // 传输事务完成的回调
                }
            )
        //...
    ).listen();
----

注意改变默认的动作实现可能会导致对 STOMP 协议标准的破坏。 所以请参考
默认的实现。

== STOMP 客户端

STOMP 客户端可以连接到 STOMP 服务器并且接受和发送数据。

=== 创建 STOMP 客户端

通过以下方式以默认配置创建 `link:../../apidocs/io/vertx/ext/stomp/StompClient.html[StompClient]` 实例：

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    // 使用连接
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

以上的代码片段创建了一个客户端连接到 "0.0.0.0:61613"。 一旦连接成功, 你就可以获得一个
`link:../../apidocs/io/vertx/ext/stomp/StompClientConnection.html[StompClientConnection]` 实例用于和服务端交互。 你可以
通过以下方式配置客户端连接的连接地址和端口：

[source,java]
----
StompClient.create(vertx)
  .connect(61613, "0.0.0.0")
  .onSuccess(connection -> {
    // 使用连接
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

为了捕获因为安全认证原因导致的异常， 或其他因为连接交互问题
产生的异常, 你可以提供一个 _异常处理器_ 给 Stomp 客户端。 所以
被该 STOMP 客户端创建的连接都会默认继承该异常处理器 (但他们也可以各自单独设置异常处理器)：

[source,java]
----
StompClient.create(vertx)
  .errorFrameHandler(frame -> {
    // 接受错误帧
  })
  .connect(61613, "0.0.0.0")
  .onSuccess(connection -> {
    // 使用连接
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

你也可以使用 `link:../../apidocs/io/vertx/ext/stomp/StompClientOptions.html[StompClientOptions]` 来配置 STOMP 客户端的连接地址和端口:

[source,java]
----
StompClient
  .create(vertx, new StompClientOptions().setHost("localhost").setPort(1234))
  .connect()
  .onSuccess(connection -> {
    // 使用连接
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== 关闭 STOMP 客户端

你可以手动关闭 STOMP 客户端:

[source,java]
----
StompClient client = StompClient
  .create(vertx, new StompClientOptions().setHost("localhost").setPort(1234));

client
  .connect()
  .onSuccess(connection -> {
    // 使用连接
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));

client.close();
----

然而, 使用以上方式关闭客户端不会告知 STOMP 服务器断开连接。 为了显式的断开连接， 你应当
使用 `link:../../apidocs/io/vertx/ext/stomp/StompClientConnection.html#disconnect--[disconnect]` 方法:

[source,java]
----
StompClient
  .create(vertx, new StompClientOptions().setHost("localhost").setPort(1234))
  .connect()
  .onSuccess(connection -> {
    // 使用连接
    connection.disconnect();
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

如果你使用了心跳并且 STOMP 客户端在配置的心跳时间内没有检测到服务端的活动， 连接
会自动关闭。

=== 错误处理

在 `link:../../apidocs/io/vertx/ext/stomp/StompClientConnection.html[StompClientConnection]` 上, 你可以注册一个错误处理器用于接收
服务端发送的 `ERROR` 帧。 注意服务端会在发送该数据后关闭连接：

[source,java]
----
StompClient
  .create(vertx, new StompClientOptions().setHost("localhost").setPort(1234))
  .connect()
  .onSuccess(connection -> {
    // 使用连接
    connection
      .errorHandler(frame ->
        System.out.println("ERROR frame received : " + frame));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

如果客户端发现当前的连接被丢弃时会收到通知。 STOMP 客户端通过心跳机制
监视连接是否时效。 当 STOMP 服务器在心跳时间窗口内没有发送心跳, 那么连接会被
关闭并且 `connectionDroppedHandler` 会被调用 (如果设置了的话)。 为了设置 `connectionDroppedHandler`, 需要调用
`link:../../apidocs/io/vertx/ext/stomp/StompClientConnection.html#connectionDroppedHandler-io.vertx.core.Handler-[connectionDroppedHandler]`。该处理器可以起到
让该 STOMP 客户端实例重新连接服务器的作用。

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {

    connection.connectionDroppedHandler(con -> {
      // 该连接已被丢失
      // 你需要重新建立连接或切换使用另一个连接
    });

    connection.send("/queue", Buffer.buffer("Hello"))
      .onSuccess(frame -> System.out.println("Message processed by the server")
      );
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== 配置

你可以通过在创建 `link:../../apidocs/io/vertx/ext/stomp/StompClient.html[StompClient]` 时传入
`link:../../apidocs/io/vertx/ext/stomp/StompClientOptions.html[StompClientOptions]` 以自定义多项配置。 由于
STOMP 客户端依赖了 `link:../../apidocs/io/vertx/core/net/NetClient.html[NetClient]`， 因此你可以在 `link:../../apidocs/io/vertx/ext/stomp/StompClientOptions.html[StompClientOptions]` 中配置
底层的 Net Client。 或者你也可以在 `link:../../apidocs/io/vertx/ext/stomp/StompClient.html#connect-io.vertx.core.net.NetClient-io.vertx.core.Handler-[connect]` 方法中
传入一个
你想使用的 `link:../../apidocs/io/vertx/core/net/NetClient.html[NetClient]`：

[source,java]
----
StompClient.create(vertx)
  .connect(netClient)
  .onSuccess(connection -> {
    // 使用连接
    connection
      .errorHandler(frame ->
        System.out.println("ERROR frame received : " + frame));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

使用 `link:../../apidocs/io/vertx/ext/stomp/StompClientOptions.html[StompClientOptions]` 可以配置：

* 连接 STOMP 服务器的地址和端口
* 连接 STOMP 服务器的登录和密码
* 如果没有显式设置 `content-length` 首部，是否自动添加 (默认开启)
* whether or not the `STOMP` command should be used instead of the `CONNECT` command (默认关闭)
* 在 `CONNECT` 帧中 `host` 首部是否被忽略  (默认关闭)
* 心跳时间配置 (默认为 1000, 1000)

=== 订阅

为了订阅一个消息目的地，使用

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    // 使用连接
    connection.subscribe("/queue", frame ->
      System.out.println("Just received a frame from /queue : " + frame));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

为了取消订阅，使用:

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    // 使用连接
    connection.subscribe("/queue", frame ->
      System.out.println("Just received a frame from /queue : " + frame));

    // ....

    connection.unsubscribe("/queue");
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== 发送消息

为了发送消息，使用:

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    Map<String, String> headers = new HashMap<>();
    headers.put("header1", "value1");
    connection.send("/queue", headers, Buffer.buffer("Hello"));
    //没有首部:
    connection.send("/queue", Buffer.buffer("World"));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

在 Java 和 Groovy 语言中， 你可以使用 `link:../../apidocs/io/vertx/ext/stomp/utils/Headers.html[Headers]` 类用于简化首部的创建。


=== 确认消息

STOMP 客户端可以发送 `ACK` 和 `NACK` 帧：

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    connection.subscribe("/queue", frame -> {
      connection.ack(frame.getAck());
      // 或者
      connection.nack(frame.getAck());
    });
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== 事务

STOMP 客户端也可以创建事务。 `ACK`, `NACK` 和 `SEND` 帧会在事务被提交时
发送。

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    Map<String, String> headers = new HashMap<>();
    headers.put("transaction", "my-transaction");
    connection.beginTX("my-transaction");
    connection.send("/queue", headers, Buffer.buffer("Hello"));
    connection.send("/queue", headers, Buffer.buffer("World"));
    connection.send("/queue", headers, Buffer.buffer("!!!"));
    connection.commit("my-transaction");
    // 或者
    connection.abort("my-transaction");
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

=== 接受

每次发送指令可以设置一个 _接收_ 处理器, 该处理器会在服务端确认处理完消息后被调用：

[source,java]
----
StompClient.create(vertx)
  .connect()
  .onSuccess(connection -> {
    connection
      .send("/queue", Buffer.buffer("Hello"))
      .onSuccess(frame ->
        System.out.println("Message processed by the server"));
  })
  .onFailure(err ->
    System.out.println(
      "Failed to connect to the STOMP server: " + err.toString()));
----

== 使用 STOMP 服务器桥接 vert.x 事件总线

STOMP 服务器可以桥接 vert.x 的事件总线。 这种桥接是双向的，这意味着 STOMP 消息
可以被转换为事件总线中的消息，并且事件总线中的消息可以被转化为 STOMP 消息。

为了使用桥接， 你需要配置入站和出站地址。 入站地址是指需要转入事件总线的
 STOMP 消息的目的地。 这些 STOMP 消息的目的地会被作为事件总线的地址。 出站地址
是指需要被转化为 STOMP 消息的事件总线地址。

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .bridge(new BridgeOptions()
            .addInboundPermitted(new PermittedOptions().setAddress("/toBus"))
            .addOutboundPermitted(new PermittedOptions().setAddress("/toStomp"))
        )
    )
    .listen();
----

默认情况下， 桥接使用 发布/订阅 模式发送消息 （主题模式）。 你也可以配置它使用点对点模式去发送
消息， 这样就只会有一个 STOMP 客户端或事件总线的消费者被调用:

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
            .bridge(new BridgeOptions()
                    .addInboundPermitted(new PermittedOptions().setAddress("/toBus"))
                    .addOutboundPermitted(new PermittedOptions().setAddress("/toStomp"))
                    .setPointToPoint(true)
            )
    )
    .listen();
----

出入站的许可字符串可以作为一个 "正则字符串" 或者一个 _匹配项_。 _匹配项_ 是指
消息体需要满足的特定结构。 以下代码演示了， 消息体必须拥有字段 "foo" ，并且
值为 "bar"。 结构匹配当前只支持 Json 数据类型。

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx)
        .bridge(new BridgeOptions()
            .addInboundPermitted(new PermittedOptions().setAddress("/toBus")
                .setMatch(new JsonObject().put("foo", "bar")))
            .addOutboundPermitted(new PermittedOptions().setAddress("/toStomp"))
            .setPointToPoint(true)
        )
    )
    .listen();
----

== 使用基于 websocket 的 STOMP 服务器

如果你想使用一个 Javascript 客户端 (在 node.js 或浏览器中) 直接连接 STOMP 服务器, 你可以使用
websocket。 STOMP 协议目前完成了适配，可以基于 websocket 工作，参见
http://jmesnil.net/stomp-websocket/doc/[StompJS] 。 使用 JavaScript 客户端直接连接到 STOMP 服务器并且
使用 websocket 协议发送消息。 这样也可以使用 websocket 接收 STOMP 消息。

为了配置服务器使用 StompJS, 你需要：

1. 使用 websocket 桥接 并且配置 websocket 需要监听的路径 (默认为 `/stomp`).
2. 在你的应用中引入 http://jmesnil.net/stomp-websocket/doc/#download[StompJS] (你的应用可以是
HTML 页面上的脚本, 或者一个 node 模块 (https://www.npmjs.com/package/stompjs).
3. 连接到服务器

为了完成第一步， 你首先需要创建一个 HTTP 服务器, 并且将
`link:../../apidocs/io/vertx/ext/stomp/StompServer.html#webSocketHandler--[webSocketHandler]` 的结果传递给
`link:../../apidocs/io/vertx/core/http/HttpServer.html#webSocketHandler-io.vertx.core.Handler-[webSocketHandler]` 方法:

[source,java]
----
StompServer server = StompServer.create(vertx, new StompServerOptions()
    .setPort(-1) // Disable the TCP port, optional
    .setWebsocketBridge(true) // Enable the web socket support
    .setWebsocketPath("/stomp")) // Configure the web socket path, /stomp by default
    .handler(StompServerHandler.create(vertx));

Future<HttpServer> http = vertx.createHttpServer(
    new HttpServerOptions().setWebSocketSubProtocols(Arrays.asList("v10.stomp", "v11.stomp"))
)
    .webSocketHandler(server.webSocketHandler())
    .listen(8080);
----

不要忘了声明要支持的子协议， 否则连接会被拒绝。

以下示例代码来自  http://jmesnil.net/stomp-websocket/doc/[the StompJS documentation] ，展示了如何连接
到服务器：

[source, javascript]
----
var url = "ws://localhost:8080/stomp";
var client = Stomp.client(url);
var callback = function(frame) {
  console.log(frame);
};

client.connect({}, function() {
var subscription = client.subscribe("foo", callback);
});
----

== 注册接收消息处理器和写入消息处理器

STOMP 客户端， 客户端连接和服务端都支持注册一个接收
`link:../../apidocs/io/vertx/ext/stomp/Frame.html[Frame]` 的处理器，该处理器会在每次接收到数据包时被调用。 你可以通过
使用它去打印数据包的日志或实现其他自定义的行为。 该处理器也会在接收 `PING`
消息, 和其他 _非法 / 未知_ 消息时被调用：

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx).receivedFrameHandler(sf -> {
      System.out.println(sf.frame());
    }))
    .listen();

StompClient client = StompClient.create(vertx).receivedFrameHandler(frame -> System.out.println(frame));
----

该处理器是在数据包被处理前调用的，因此可以使用它来 _修改_ 数据包

使用了不合法的指令的数据包会被当做 `UNKNOWN` 指令处理。 原本的指令会被写入
首部，其字段为 `link:../../apidocs/io/vertx/ext/stomp/Frame.html#STOMP_FRAME_COMMAND[Frame.STOMP_FRAME_COMMAND]`

你也可以设置一个处理器，该处理器会在数据包被发送前调用 (写入到网络前):

[source,java]
----
Future<StompServer> server = StompServer.create(vertx)
    .handler(StompServerHandler.create(vertx))
    .writingFrameHandler(sf -> {
      System.out.println(sf.frame());
    })
    .listen();

StompClient client = StompClient.create(vertx).writingFrameHandler(frame -> {
  System.out.println(frame);
});
----