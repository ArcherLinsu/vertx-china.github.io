= Vertx unit

//Asynchronous polyglot unit testing.
异步多语言单元测试。

//== Introduction
== 介绍
[[_introduction]]

//Vertx Unit is designed for writing asynchronous unit tests with a polyglot API and running these tests
//in the JVM. Vertx Unit Api borrows from existing test frameworks like http://junit.org[JUnit] or http://qunitjs.com[QUnit]
//and follows the Vert.x practices.
Vert.x Unit 用多语言的异步API在JVM上 运行单元测试。
Vert.x Unit 借鉴了已有的测试框架，例如 http://junit.org[JUnit] or http://qunitjs.com[QUnit]
并同时遵循了Vert.x的做法。

//As a consequence Vertx Unit is the natural choice for testing Vert.x applications.
所以 Vert.x Unit 自然就成为了测试 Vert.x 应用的选择。

//To use vert.x unit, add the following dependency to the _dependencies_ section of your build descriptor:
要使用 Vert.x Unit，
那么请添加如下依赖：

* Maven (在您的 `pom.xml` 文件):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-unit</artifactId>
 <version>4.0.3</version>
 <scope>test</scope>
</dependency>
----

* Gradle (在您的 `build.gradle` 文件):

[source,groovy,subs="+attributes"]
----
testCompile ${io.vertx}:${vertx-unit}:4.0.3
----

//Vert.x unit can be used in different ways and run anywhere your code runs, it is just a matter of reporting
//the results the right way, this example shows the bare minimum test suite:
Vert.x Unit 能够以各种方式使用并可以在您代码中任何位置运行，它仅以正确的方式报告执行结果。
以下示例展示了一个最简的测试用例套件。

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.test("my_test_case", context -> {
  String s = "value";
  context.assertEquals("value", s);
});
suite.run();
----

//The `run` method will execute the suite and go through all the
//tests of the suite. The suite can fail or pass, this does not matter if the outer world is not aware
//of the test result.
`run` 方法执行了整个套件并且执行套件中所有的测试用例。
测试用例套件可能失败也可能通过。如果外界不关心测试结果，
那么测试用例的通过与否便不重要。

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.test("my_test_case", context -> {
  String s = "value";
  context.assertEquals("value", s);
});
suite.run(new TestOptions().addReporter(new ReportOptions().setTo("console")));
----

//When executed, the test suite now reports to the console the steps of the test suite:
执行之时，
测试套件会在控制台报告每一步的结果：

----
Begin test suite the_test_suite
Begin test my_test
Passed my_test
End test suite the_test_suite , run: 1, Failures: 0, Errors: 0
----

//The `reporters` option configures the reporters used by the suite runner for reporting the execution
//of the tests, see the <<reporting>> section for more info.
`reporters` 选项配置了套件执行器的reporter，用以报告测试用例执行结果，
更多信息详见 <<reporting>> 章节

//== Writing a test suite
== 编写一个测试套件
[[_writing_a_test_suite]]

//A test suite is a named collection of test case, a test case is a straight callback to execute. The suite can
//have lifecycle callbacks to execute _before_ and/or _after_ the test cases or the test suite that are used for
//initializing or disposing services used by the test suite.
测试套件是一系列测试用例组成的有名称的集合，测试用例则是一个直接回调。
套件生命周期中可以设置回调函数，这些函数可以在执行测试用例前后执行，
也可以在用作初始化/发布服务的套件前后。

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.test("my_test_case_1", context -> {
  // Test 1
});
suite.test("my_test_case_2", context -> {
  // Test 2
});
suite.test("my_test_case_3", context -> {
  // Test 3
});
----

//The API is fluent and therefore the test cases can be chained:
流式API让测试用例可以作链式调用：

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.test("my_test_case_1", context -> {
  // Test 1
}).test("my_test_case_2", context -> {
  // Test 2
}).test("my_test_case_3", context -> {
  // Test 3
});
----

//The test cases declaration order is not guaranteed, so test cases should not rely on the execution of
//another test case to run. Such practice is considered as a bad one.
测试用例的声明顺序并不保证其执行顺序，所以测试用例不可以依赖于其他测试用例来运行。
这不是一个好的做法。

//Vertx Unit provides _before_ and _after_ callbacks for doing global setup or cleanup:
Vert.x Unit 提供了 _before_ 和 _after_ 回调来作总体的启动或清理资源操作：

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.before(context -> {
  // 测试套件启动
}).test("my_test_case_1", context -> {
  // Test 1
}).test("my_test_case_2", context -> {
  // Test 2
}).test("my_test_case_3", context -> {
  // Test 3
}).after(context -> {
  // 测试套件清理资源
});
----

//The declaration order of the method does not matter, the example declares the _before_ callback before
//the test cases and _after_ callback after the test cases but it could be anywhere, as long as it is done before
//running the test suite.
这些方法的声明顺序并不重要，示例中在用例之前声明 _before_ ，
在用例之后声明 _after_ ，然而，
在运行套件之前，他们可以声明于任何位置，

//The _before_ callback is executed before any tests, when it fails, the test suite execution will stop and the
//failure is reported. The _after_ callback is the last callback executed by the testsuite, unless
//the _before_ callback reporter a failure.
_before_ 回调函数执行于所有测试用例之前，如果其运行失败，
则整个测试套件将停止运行并报告失败结果。 _after_ 回调函数在整个测试套件中最后执行，
除非 _before_ 回调函数运行失败。

//Likewise, Vertx Unit provides the _beforeEach_ and _afterEach_ callback that do the same but are executed
//for each test case:
类似的，Vert.x Unit 提供了 _beforeEach_ 和 _afterEach_ 回调，
用以在每一个测试用例前后执行：

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.beforeEach(context -> {
  // 测试用例启动
}).test("my_test_case_1", context -> {
  // Test 1
}).test("my_test_case_2", context -> {
  // Test 2
}).test("my_test_case_3", context -> {
  // Test 3
}).afterEach(context -> {
  // 测试用例资源清理
});
----

//The _beforeEach_ callback is executed before each test case, when it fails, the test case is not executed and the
//failure is reported. The _afterEach_ callback is the executed just after the test case callback, unless
//the _beforeEach_ callback reported a failure.
_beforeEach_ 回调函数执行于每一个测试用例之前，一旦其运行失败，那测试用例将不再被执行，
并报告失败结果。 _afterEach_ 回调函数仅在测试用例之后被执行，
除非 _beforeEach_ 函数运行失败。

//== Asserting
== 断言
[[_asserting]]

//Vertx Unit provides the `link:../../apidocs/io/vertx/ext/unit/TestContext.html[TestContext]` object for doing assertions in test cases. The _context_
//object provides the usual methods when dealing with assertions.
Vert.x Unit 提供了 `link:../../apidocs/io/vertx/ext/unit/TestContext.html[TestContext]` 对象用来在测试用例中作断言操作。
_context_ 对象提供了用于断言的常用方法。

=== assertEquals

//Assert two objects are equals, works for _basic_ types or _json_ types.
断言两个对象相等，适用于 _基本类型_ 和 _json类型_ 。

[source,java]
----
suite.test("my_test_case", context -> {
  context.assertEquals(10, callbackCount);
});
----

//There is also an overloaded version for providing a message:
有一个重载的方法用于提供测试信息：

[source,java]
----
suite.test("my_test_case", context -> {
  context.assertEquals(10, callbackCount, "Should have been 10 instead of " + callbackCount);
});
----

//Usually each assertion provides an overloaded version.
通常地，每一个断言函数都提供了重载的版本。

=== assertNotEquals

//The counter part of _assertEquals_.
与 _assertEquals_ 相反。

[source,java]
----
suite.test("my_test_case", context -> {
  context.assertNotEquals(10, callbackCount);
});
----

=== assertNull

//Assert an object is null, works for _basic_ types or _json_ types.
断言一个对象是null，适用于 _基本类型_ 和 _json类型_ 。

[source,java]
----
suite.test("my_test_case", context -> {
  context.assertNull(null);
});
----

=== assertNotNull

//The counter part of _assertNull_.
与 _assertNull_ 相反。

[source,java]
----
suite.test("my_test_case", context -> {
  context.assertNotNull("not null!");
});
----

=== assertInRange

//The `link:../../apidocs/io/vertx/ext/unit/TestContext.html#assertInRange-double-double-double-[assertInRange]` targets real numbers.
`link:../../apidocs/io/vertx/ext/unit/TestContext.html#assertInRange-double-double-double-[assertInRange]` 方法作用于实数范围。

----
suite.test("my_test_case", context -> {

  // 断言0.1 在误差范围 +/- 0.5范围内等于0.2

  context.assertInRange(0.1, 0.2, 0.5);
});
----

=== assertTrue and assertFalse

//Asserts the value of a boolean expression.
对于布尔表达式的断言。

[source,java]
----
suite.test("my_test_case", context -> {
  context.assertTrue(var);
  context.assertFalse(value > 10);
});
----

//=== Failing
=== 失败
[[_failing]]

//Last but not least, _test_ provides a _fail_ method that will throw an assertion error:
最后（并非不重要），_test_ 提供了一个 _fail_ 方法用来抛出断言错误的异常：

[source,java]
----
suite.test("my_test_case", context -> {
  context.fail("That should never happen");
  // 剩下的代码不会执行。
});
----

//The failure can either be a _string_ as seen previously or an _error_. The _error_ object depends
//on the target language, for Java or Groovy it can be any class extending _Throwable- , for
//JavaScript it is an _error_, for Ruby it is an _Exception_.
`失败` 对象本身既可以是 _string_ 也可以是一个 _error_。
_error_ 对象取决于所使用的编程语言，对于 Java 或者 Groovy 而言，可以是任何 _Throwable_ 的子类，
对于 JavaScript 则是一个 _error_ ，对于 Ruby 则是一个 _Exception_。

//=== Using third-party assertion framework
=== 使用第三方断言框架
[[_using_third_party_assertion_framework]]

//It is also possible to use any other assertion framework, like the popular _hamcrest_ and _assertj_.
//The recommended way to go is to use `link:../../apidocs/io/vertx/ext/unit/TestContext.html#verify-io.vertx.core.Handler-[verify]`
//and perform the assertions within the supplied _Handler_. This way, asynchronous testing termination
//will be correctly handled.
您也可以用任何其他的断言框架，例如比较流行的 _hamcrest_ 和 _assertj_ 。
我们建议您用 `link:../../apidocs/io/vertx/ext/unit/TestContext.html#verify-io.vertx.core.Handler-[verify]` ，
使用我们提供的 _Handler_ 来进行断言。
这样的话，我们才能正确的处理异步测试的结束动作。

[source,java]
----
suite.test("my_test_case", context -> context.verify(v -> {
  // 这里 junit中的 Assert 对象可以是 assertj hamcrest或其他库中的Assert对象
  // 甚至可以手动抛出 AssertionError
  Assert.assertNotNull("not null!");
  Assert.assertEquals(10, callbackCount);
}));
----

//== Asynchronous testing
== 异步测试
[[_asynchronous_testing]]

//The previous examples supposed that test cases were terminated after their respective callbacks, this is the
//default behavior of a test case callback. Often it is desirable to terminate the test after the test case
//callback, for instance:
前述示例的前提是，假设所有的测试用例在各自回调之后会结束，
这是测试用例回调函数的默认行为。在测试用例回调函数之后结束测试是可取的，
例如：

//.The Async object asynchronously completes the test case
.Async 对象异步的完成测试用例
[source,java]
----
suite.test("my_test_case", context -> {
  Async async = context.async();
  eventBus.consumer("the-address", msg -> {
    // <2>
    async.complete();
  });
  // <1>
});
----
<1> 回调函数结束，但是测试用例没结束
<2> 总线事件的回调函数来终止测试

//Creating an `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]` object with the `link:../../apidocs/io/vertx/ext/unit/TestContext.html#async--[async]` method marks the
//executed test case as non terminated. The test case terminates when the `link:../../apidocs/io/vertx/ext/unit/Async.html#complete--[complete]`
//method is invoked.
用 `link:../../apidocs/io/vertx/ext/unit/TestContext.html#async--[async]` 方法创建一个 `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]` 对象表示测试用例还未结束。
当执行 `link:../../apidocs/io/vertx/ext/unit/Async.html#complete--[complete]` 方法时，
测试用例才算结束。

//NOTE: When the `complete` callback is not invoked, the test case fails after a certain timeout.
NOTE: 当 `complete` 回调函数未被执行时，测试用例会在指定超时时间之后失败。

//Several `Async` objects can be created during the same test case, all of them must be _completed_ to terminate
//the test.
同一个测试用例中可以创建多个 `Async` 对象，
必须调用所有Async对象的 _completed_ 方法来终止测试。

//.Several Async objects provide coordination
.多个Async对象合作
[source,java]
----
suite.test("my_test_case", context -> {

  HttpClient client = vertx.createHttpClient();
  client.request(HttpMethod.GET, 8080, "localhost", "/", context.asyncAssertSuccess(req -> {
      req.send(context.asyncAssertSuccess(resp -> {
        context.assertEquals(200, resp.statusCode());
      }));
    }));

  Async async = context.async();
  vertx.eventBus().consumer("the-address", msg -> {
    async.complete();
  });
});
----

//Async objects can also be used in _before_ or _after_ callbacks, it can be very convenient in a _before_ callback
//to implement a setup that depends on one or several asynchronous results:
Async 对象也可以用在 _before_ 或 _after_ 回调中，
这将很方便的在 _before_ 回调中，实现依赖于多个异步结果的启动操作：

//.Async starts an http server before test cases
.执行测试用例之前异步启动 http server
[source,java]
----
suite.before(context -> {
  Async async = context.async();
  HttpServer server = vertx.createHttpServer();
  server.requestHandler(requestHandler);
  server.listen(8080, ar -> {
    context.assertTrue(ar.succeeded());
    async.complete();
  });
});
----

//It is possible to wait until the completion of a specific `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]`, similar
//to Java's count-down latch:
您也可以等待 `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]` 直到其结束，
类似Java的 count-down latch：

.Wait for completion
[source, java]
----
Async async = context.async();
HttpServer server = vertx.createHttpServer();
server.requestHandler(requestHandler);
server.listen(8080, ar -> {
  context.assertTrue(ar.succeeded());
  async.complete();
});

// Wait until completion
async.awaitSuccess();
----

//WARNING: this should not be executed from the event loop!
WARNING: 这个方法不应该从event loop上执行！

//Async can also be created with an initial count value, it completes when the count-down reaches
//zero using `link:../../apidocs/io/vertx/ext/unit/Async.html#countDown--[countDown]`:
Async 可以创建一个初始计数值，
当用 `link:../../apidocs/io/vertx/ext/unit/Async.html#countDown--[countDown]` 方法将 count-down 的值减到0时：

//.Wait until the complete count-down reaches zero
.等待，直到count-down值为0
[source, java]
----
Async async = context.async(2);
HttpServer server = vertx.createHttpServer();
server.requestHandler(requestHandler);
server.listen(8080, ar -> {
  context.assertTrue(ar.succeeded());
  async.countDown();
});

vertx.setTimer(1000, id -> {
  async.complete();
});

// Wait until completion of the timer and the http request
async.awaitSuccess();
----

//Calling `complete()` on an async completes the async as usual, it actually sets the value to `0`.
调用Async的 `complete()` 方法会像往常一样结束，实际上它将count-down值直接设置为 `0` 。

//== Asynchronous assertions
== 异步断言
[[_asynchronous_assertions]]

//`link:../../apidocs/io/vertx/ext/unit/TestContext.html[TestContext]` provides useful methods that provides powerful constructs for async testing:
`link:../../apidocs/io/vertx/ext/unit/TestContext.html[TestContext]` 提供了很有用的方法，这些方法提供了强大的异步测试框架：

//The `link:../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess--[asyncAssertSuccess]` method returns an {@literal Handler<AsyncResult<T>>}
//instance that acts like `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]`, resolving the `Async` on success and failing the test
//on failure with the failure cause.
`link:../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess--[asyncAssertSuccess]` 方法返回一个类似 `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]` {@literal Handler<AsyncResult<T>>} 对象，
它在运行成功时执行 `Async` 对象，并在失败时，
让整个测试用例失败，并返回失败原因。

[source,java]
----
Async async = context.async();
vertx.deployVerticle("my.verticle", ar -> {
  if (ar.succeeded()) {
    async.complete();
  } else {
    context.fail(ar.cause());
  }
});

// 可用如下代替

vertx.deployVerticle("my.verticle", context.asyncAssertSuccess());
----

//The `link:../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess-io.vertx.core.Handler-[asyncAssertSuccess]` method returns an {@literal Handler<AsyncResult<T>>}
//instance that acts like `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]`, invoking the delegating {@literal Handler<T>} on success
//and failing the test on failure with the failure cause.
`link:../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertSuccess-io.vertx.core.Handler-[asyncAssertSuccess]` 方法返回一个类似于 `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]` 的 {@literal Handler<AsyncResult<T>>} 对象，
运行成功时它执行了代理 {@literal Handler<T>} ，
而在运行出错时让整个测试用例失败，并返回错误原因。

[source,java]
----
AtomicBoolean started = new AtomicBoolean();
Async async = context.async();
vertx.deployVerticle(new AbstractVerticle() {
  public void start() throws Exception {
    started.set(true);
  }
}, ar -> {
  if (ar.succeeded()) {
    context.assertTrue(started.get());
    async.complete();
  } else {
    context.fail(ar.cause());
  }
});

// Can be replaced by

vertx.deployVerticle("my.verticle", context.asyncAssertSuccess(id -> {
  context.assertTrue(started.get());
}));
----

//The async is completed when the `Handler` exits, unless new asyncs were created during the invocation, which
//can be handy to _chain_ asynchronous behaviors:
当 `Handler` 退出时，Async对象同时也会处于 `completed` 状态，除非Async对象在函数调用期间被创建，
这会在 _链式_ 异步操作时提供方便：

[source,java]
----
Async async = context.async();
vertx.deployVerticle("my.verticle", ar1 -> {
  if (ar1.succeeded()) {
    vertx.deployVerticle("my.otherverticle", ar2 -> {
      if (ar2.succeeded()) {
        async.complete();
      } else {
        context.fail(ar2.cause());
      }
    });
  } else {
    context.fail(ar1.cause());
  }
});

// Can be replaced by

vertx.deployVerticle("my.verticle", context.asyncAssertSuccess(id ->
        vertx.deployVerticle("my_otherverticle", context.asyncAssertSuccess())
));
----

//The `link:../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure--[asyncAssertFailure]` method returns an {@literal Handler<AsyncResult<T>>}
//instance that acts like `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]`, resolving the `Async` on failure and failing the test
//on success.
`link:../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure--[asyncAssertFailure]` 方法返回了一个类似 `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]` 的 {@literal Handler<AsyncResult<T>>} 对象,
它在运行失败时执行 `Async` ，
并在成功时让测试用例失败。

[source,java]
----
Async async = context.async();
vertx.deployVerticle("my.verticle", ar -> {
  if (ar.succeeded()) {
    context.fail();
  } else {
    async.complete();
  }
});

// 可用如下代替

vertx.deployVerticle("my.verticle", context.asyncAssertFailure());
----

//The `link:../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure-io.vertx.core.Handler-[asyncAssertFailure]` method returns an {@literal Handler<AsyncResult<T>>}
//instance that acts like `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]`, invoking the delegating {@literal Handler<Throwable>} on
//failure and failing the test on success.
//`link:../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure-io.vertx.core.Handler-[asyncAssertFailure]`
`link:../../apidocs/io/vertx/ext/unit/TestContext.html#asyncAssertFailure-io.vertx.core.Handler-[asyncAssertFailure]` 方法返回一个类似 `link:../../apidocs/io/vertx/ext/unit/Async.html[Async]` 的  {@literal Handler<AsyncResult<T>>} 对象，
它在运行失败时，
执行代理处理器 {@literal Handler<Throwable>} ，
并在执行成功时让测试用例失败。

[source,java]
----
Async async = context.async();
vertx.deployVerticle("my.verticle", ar -> {
  if (ar.succeeded()) {
    context.fail();
  } else {
    context.assertTrue(ar.cause() instanceof IllegalArgumentException);
    async.complete();
  }
});

// 可用如下代替

vertx.deployVerticle("my.verticle", context.asyncAssertFailure(cause -> {
  context.assertTrue(cause instanceof IllegalArgumentException);
}));
----

//The async is completed when the `Handler` exits, unless new asyncs were created during the invocation.
`Handler` 退出时，这个Async也会处于完成状态，除非在执行过程中，创建了新的Async对象

//== Repeating test
== 重复测试
[[_repeating_test]]

//When a test fails randomly or not often, for instance a race condition, it is convenient to run the same
//test multiple times to increase the failure likelihood of the test.
当测试随机条件或测试不经常失败时，例如在竞争条件下，
为了增加测试失败的可能性，多次运行同一测试是个方便的方式。

//.Repeating a test
.重复一个测试
[source,java]
----
TestSuite.create("my_suite").test("my_test", 1000, context -> {
  // 这里会执行1000次
});
----

//When declared, _beforeEach_ and _afterEach_ callbacks will be executed as many times as the test is executed.
如果声明了 _beforeEach_ 和 _afterEach_ 回调，那么每当测试用例执行一次，它们也会被执行一次。

//NOTE: test repetition are executed sequentially
NOTE: 重复的测试用例是顺序执行的

//== Sharing objects
== 共享对象
[[_sharing_objects]]

The `link:../../apidocs/io/vertx/ext/unit/TestContext.html[TestContext]` has `get`/`put`/`remove` operations for sharing state between callbacks.

Any object added during the _before_ callback is available in any other callbacks. Each test case will operate on
a copy of the shared state, so updates will only be visible for a test case.

.Sharing state between callbacks
[source,java]
----
TestSuite.create("my_suite").before(context -> {

  // host is available for all test cases
  context.put("host", "localhost");

}).beforeEach(context -> {

  // Generate a random port for each test
  int port = helper.randomPort();

  // Get host
  String host = context.get("host");

  // Setup server
  Async async = context.async();
  HttpServer server = vertx.createHttpServer();
  server.requestHandler(req -> {
    req.response().setStatusCode(200).end();
  });
  server.listen(port, host, ar -> {
    context.assertTrue(ar.succeeded());
    context.put("port", port);
    async.complete();
  });

}).test("my_test", context -> {

  // Get the shared state
  int port = context.get("port");
  String host = context.get("host");

  // Do request
  HttpClient client = vertx.createHttpClient();
  client.request(HttpMethod.GET, port, host, "/resource", context.asyncAssertSuccess(req -> {
    req.send(context.asyncAssertSuccess(resp -> {
      context.assertEquals(200, resp.statusCode());
    }));
  }));
});
----

WARNING: sharing any object is only supported in Java, other languages can share only basic or json types.
Other objects should be shared using the features of that language.

== Running

When a test suite is created, it won't be executed until the `link:../../apidocs/io/vertx/ext/unit/TestSuite.html#run--[run]` method
is called.

.Running a test suite
[source,java]
----
suite.run();
----

The test suite can also be run with a specified `link:../../apidocs/io/vertx/core/Vertx.html[Vertx]` instance:

.Provides a Vertx instance to run the test suite
[source,java]
----
suite.run(vertx);
----

When running with a `Vertx` instance, the test suite is executed using the Vertx event loop, see the <<event_loop>>
section for more details.

A test suite can be run with the Vert.x Command Line Interface with the `vertx test` command:

.Running a test suite with the Vert.x CLI
[source]
----
> vertx test the_test_suite.js
Begin test suite the_test_suite
Succeeded in deploying verticle
Begin test my_test_case
Passed my_test_case
End test suite my_suite , run: 1, Failures: 0, Errors: 0
----

Such test suite just need to be executed via the `link:../../apidocs/io/vertx/ext/unit/TestSuite.html#run--[run]` command, the
`vertx test` command takes care of configuring reporting, timeout, etc..., pretty much like in this
example:

[source,java]
----
TestSuite suite = TestSuite.create("the_test_suite");
suite.test("my_test_case", context -> {
  String s = "value";
  context.assertEquals("value", s);
});
suite.run();
----

The `vertx test` command extends the `vertx run` command. The exit behavior of the JVM is changed
the JVM exits when the test suite is executed and a return value is provided indicating the tests
success (0) or failure (1).

NOTE: several test suites can executed in the same verticle, Vert.x Unit waits until completion of
all suite executed.

=== Test suite completion

No assumptions can be made about when the test suite will be completed, and if some code needs to be executed
after the test suite, it should either be in the test suite _after_ callback or as callback of the
`link:../../apidocs/io/vertx/ext/unit/Completion.html[Completion]`:

.Test suite execution callback
[source,java]
----
TestCompletion completion = suite.run(vertx);

// Simple completion callback
completion.handler(ar -> {
  if (ar.succeeded()) {
    System.out.println("Test suite passed!");
  } else {
    System.out.println("Test suite failed:");
    ar.cause().printStackTrace();
  }
});
----

The `link:../../apidocs/io/vertx/ext/unit/Completion.html[Completion]` object provides also a `link:../../apidocs/io/vertx/ext/unit/Completion.html#resolve-io.vertx.core.Promise-[resolve]` method that
takes a `Promise` object, this `Promise` will be notified of the test suite execution:

.Resolving the start Promise with the test suite
[source,java]
----
TestCompletion completion = suite.run();

// When the suite completes, the promise is resolved
completion.resolve(startPromise);
----

This allow to easily create a _test_ verticle whose deployment is the test suite execution, allowing the
code that deploys it to be easily aware of the success or failure.

The completion object can also be used like a latch to block until the test suite completes. This should
be used when the thread running the test suite is not the same than the current thread:

.Blocking until the test suite completes
[source,java]
----
Completion completion = suite.run();

// Wait until the test suite completes
completion.await();
----

The `await` throws an exception when the thread is interrupted or a timeout is fired.

The `link:../../apidocs/io/vertx/ext/unit/Completion.html#awaitSuccess--[awaitSuccess]` is a variation that throws an exception when
the test suite fails.

.Blocking until the test suite succeeds
[source,java]
----
Completion completion = suite.run();

// Wait until the test suite succeeds otherwise throw an exception
completion.awaitSuccess();
----

=== Time out

Each test case of a test suite must execute before a certain timeout is reached. The default timeout is
of _2 minutes_, it can be changed using _test options_:

.Setting the test suite timeout
[source,java]
----
TestOptions options = new TestOptions().setTimeout(10000);

// Run with a 10 seconds time out
suite.run(options);
----

[[event_loop]]
=== Event loop

Vertx Unit execution is a list of tasks to execute, the execution of each task is driven by the completion
of the previous task. These tasks should leverage Vert.x event loop when possible but that depends on the
current execution context (i.e the test suite is executed in a `main` or embedded in a `Verticle`) and
wether or not a `Vertx` instance is configured.

The `link:../../apidocs/io/vertx/ext/unit/TestOptions.html#setUseEventLoop-java.lang.Boolean-[setUseEventLoop]` configures the usage of the event
loop:

.Event loop usage
|===
| | useEventLoop:null | useEventLoop:true | useEventLoop:false

| `Vertx` instance
| use vertx event loop
| use vertx event loop
| force no event loop

| in a `Verticle`
| use current event loop
| use current event loop
| force no event loop

| in a _main_
| use no event loop
| raise an error
| use no event loop

|===

The default `useEventLoop` value is `null`, that means that it will uses an event loop when possible and fallback
to no event loop when no one is available.

[[reporting]]
== Reporting

Reporting is an important piece of a test suite, Vertx Unit can be configured to run with different kind
of reporters.

By default no reporter is configured, when running a test suite, _test options_ can be provided to
configure one or several:

.Using the console reporter and as a junit xml file
[source,java]
----
ReportOptions consoleReport = new ReportOptions().
    setTo("console");

// Report junit files to the current directory
ReportOptions junitReport = new ReportOptions().
    setTo("file:.").
    setFormat("junit");

suite.run(new TestOptions().
        addReporter(consoleReport).
        addReporter(junitReport)
);
----

=== Console reporting

Reports to the JVM `System.out` and `System.err`:

to::
_console_
format::
_simple_ or _junit_

=== File reporting

Reports to a file, a `Vertx` instance must be provided:

to::
_file_ `:` _dir name_
format::
_simple_ or _junit_
example::
`file:.`

The file reporter will create files in the configured directory, the files will be named after the
test suite name executed and the format (i.e _simple_ creates _txt_ files and _junit_ creates _xml_
files).

=== Log reporting

Reports to a logger, a `Vertx` instance must be provided:

to::
_log_ `:` _logger name_
example::
`log:mylogger`

=== Event bus reporting

Reports events to the event bus, a `Vertx` instance must be provided:

to::
_bus_ `:` _event bus address_
example::
`bus:the-address`

It allow to decouple the execution of the test suite from the reporting.

The messages sent over the event bus can be collected by the `link:../../apidocs/io/vertx/ext/unit/collect/EventBusCollector.html[EventBusCollector]`
and achieve custom reporting:

[source,java]
----
EventBusCollector collector = EventBusCollector.create(
    vertx,
    new ReportingOptions().addReporter(
        new ReportOptions().setTo("file:report.xml").setFormat("junit")));

collector.register("the-address");
----

[[vertx_integration]]
== Vertx integration

By default, assertions and failures must be done on the `link:../../apidocs/io/vertx/ext/unit/TestContext.html[TestContext]` and throwing an
assertion error works only when called by Vert.x Unit:

[source,java]
----
suite.test("my_test_case", ctx -> {

  // The failure will be reported by Vert.x Unit
  throw new RuntimeException("it failed!");
});
----

In a regular Vert.x callback, the failure will be ignored:

[source,java]
----
suite.test("test-server", testContext -> {
  HttpServer server = vertx.createHttpServer().requestHandler(req -> {
    if (req.path().equals("/somepath")) {
      throw new AssertionError("Wrong path!");
    }
    req.response().end();
  });
});
----

Since Vert.x 3.3, a global exception handler can be set to report the event loop uncaught exceptions:

[source,java]
----
suite.before(testContext -> {

  // Report uncaught exceptions as Vert.x Unit failures
  vertx.exceptionHandler(testContext.exceptionHandler());
});

suite.test("test-server", testContext -> {
  HttpServer server = vertx.createHttpServer().requestHandler(req -> {
    if (req.path().equals("/somepath")) {
      throw new AssertionError("Wrong path!");
    }
    req.response().end();
  });
});
----

The exception handler is set during the _before_ phase, the `link:../../apidocs/io/vertx/ext/unit/TestContext.html[TestContext]` is shared
between each _before_, _test_ and _after_ phase. So the exception handler obtained during the _before_ phase
is correct.

== Junit integration

Although Vertx Unit is polyglot and not based on JUnit, it is possible to run a Vertx Unit test suite or a test case
from JUnit, allowing you to integrate your tests with JUnit and your build system or IDE.

.Run a Java class as a JUnit test suite
[source,java]
----
@RunWith(VertxUnitRunner.class)
public class JUnitTestSuite {
  @Test
  public void testSomething(TestContext context) {
    context.assertFalse(false);
  }
}
----

The `link:../../apidocs/io/vertx/ext/unit/junit/VertxUnitRunner.html[VertxUnitRunner]` uses the junit annotations for introspecting the class
and create a test suite after the class. The methods should declare a `link:../../apidocs/io/vertx/ext/unit/TestContext.html[TestContext]`
argument, if they don't it is fine too. However the `TestContext` is the only way to retrieve the associated
Vertx instance of perform asynchronous tests.

The JUnit integration is also available for the Groovy language with the `io.vertx.groovy.ext.unit.junit.VertxUnitRunner`
runner.

=== Running a test on a Vert.x context

By default the thread invoking the test methods is the JUnit thread. The `link:../../apidocs/io/vertx/ext/unit/junit/RunTestOnContext.html[RunTestOnContext]`
JUnit rule can be used to alter this behavior for running these test methods with a Vert.x event loop thread.

Thus there must be some care when state is shared between test methods and Vert.x handlers as they won't be
on the same thread, e.g incrementing a counter in a Vert.x handler and asserting the counter in the test method.
One way to solve this is to use proper synchronization, another is to execute test methods on a Vert.x context
that will be propagated to the created handlers.

For this purpose the `link:../../apidocs/io/vertx/ext/unit/junit/RunTestOnContext.html[RunTestOnContext]` rule needs a `link:../../apidocs/io/vertx/core/Vertx.html[Vertx]`
instance. Such instance can be provided, otherwise the rule will manage an instance under the hood. Such
instance can be retrieved when the test is running, making this rule a way to manage a `link:../../apidocs/io/vertx/core/Vertx.html[Vertx]`
instance as well.

.Run a Java class as a JUnit test suite
[source,java]
----
@RunWith(VertxUnitRunner.class)
public class RunOnContextJUnitTestSuite {

  @Rule
  public RunTestOnContext rule = new RunTestOnContext();

  @Test
  public void testSomething(TestContext context) {
    // Use the underlying vertx instance
    Vertx vertx = rule.vertx();
  }
}
----

The rule can be annotated by {@literal @Rule} or {@literal @ClassRule}, the former manages a Vert.x instance
per test, the later a single Vert.x for the test methods of the class.

WARNING: keep in mind that you cannot block the event loop when using this rule. Usage of classes like
`CountDownLatch` or similar classes must be done with care.

=== Timeout

The Vert.x Unit 2 minutes timeout can be overriden with the `timeout` member of the `@Test` annotation:

.Configure the timeout at the test level
[source,java]
----
public class JunitTestWithTimeout {

  @Test(timeout = 1000l)
  public void testSomething(TestContext context) {
    //...
  }

}
----

For a more global configuration, the `link:../../apidocs/io/vertx/ext/unit/junit/Timeout.html[Timeout]` rule can be used:

.Configure the timeout at the class level
[source,java]
----
@RunWith(VertxUnitRunner.class)
public class TimeoutTestSuite {

  @Rule
  public Timeout rule = Timeout.seconds(1);

  @Test
  public void testSomething(TestContext context) {
    //...
  }
}
----

NOTE: the `@Test` timeout overrides the the `link:../../apidocs/io/vertx/ext/unit/junit/Timeout.html[Timeout]` rule.

=== Parameterized tests

JUnit provides useful `Parameterized` tests, Vert.x Unit tests can be ran with this particular runner thanks to
the `link:../../apidocs/io/vertx/ext/unit/junit/VertxUnitRunnerWithParametersFactory.html[VertxUnitRunnerWithParametersFactory]`:

.Running a Vert.x Unit parameterized test
[source,java]
----
@RunWith(Parameterized.class)
@Parameterized.UseParametersRunnerFactory(VertxUnitRunnerWithParametersFactory.class)
public class SimpleParameterizedTest {

  @Parameterized.Parameters
  public static Iterable<Integer> data() {
    return Arrays.asList(0, 1, 2);
  }

  public SimpleParameterizedTest(int value) {
    //...
  }

  @Test
  public void testSomething(TestContext context) {
    // Execute test with the current value
  }
}
----

Parameterized tests can also be done in Groovy with the `io.vertx.groovy.ext.unit.junit.VertxUnitRunnerWithParametersFactory`.

=== Repeating a test

When a test fails randomly or not often, for instance a race condition, it is convenient to run the same
test multiple times to increase the likelihood failure of the test.

With JUnit a test has to be annotated with `link:../../apidocs/io/vertx/ext/unit/junit/Repeat.html[@Repeat]` to be repeated. The test must
also define the `link:../../apidocs/io/vertx/ext/unit/junit/RepeatRule.html[RepeatRule]` among its rules.

.Repeating a test with JUnit
[source,java]
----
@RunWith(VertxUnitRunner.class)
public class RepeatingTest {

  @Rule
  public RepeatRule rule = new RepeatRule();

  @Repeat(1000)
  @Test
  public void testSomething(TestContext context) {
    // This will be executed 1000 times
  }
}
----

When declared, _before_ and _after_ life cycle will be executed as many times as the test is executed.

NOTE: test repetition are executed sequentially

=== Using with other assertion libraries

Vert.x Unit usability has been greatly improved in Vert.x 3.3. You can now write tests using
http://hamcrest.org/[Hamcrest], http://joel-costigliola.github.io/assertj/[AssertJ],
https://github.com/rest-assured/rest-assured/[Rest Assured], or any assertion library you want. This is made
possible by the global exception handler described in <<vertx_integration>>.

You can find Java examples of using Vert.x Unit with Hamcrest and AssertJ in the
https://github.com/vert-x3/vertx-examples/tree/master/unit-examples[vertx-examples] project.

== Java language integration

=== Test suite integration

The Java language provides classes and it is possible to create test suites directly from Java classes with the
following mapping rules:

The `testSuiteObject` argument methods are inspected and the public, non static methods
with `link:../../apidocs/io/vertx/ext/unit/TestContext.html[TestContext]` parameter are retained and mapped to a Vertx Unit test suite
via the method name:

* `before` : before callback
* `after` : after callback
* `beforeEach` : beforeEach callback
* `afterEach` : afterEach callback
*  when the name starts with _test_ : test case callback named after the method name

.Test suite written using a Java class
[source,java]
----
public class MyTestSuite {

  public void testSomething(TestContext context) {
    context.assertFalse(false);
  }
}
----

This class can be turned into a Vertx test suite easily:

.Create a test suite from a Java object
[source,java]
----
TestSuite suite = TestSuite.create(new MyTestSuite());
----