= Vert.x Json Schema
:toc: left

Vert.x Json Schema组件提供了一个可扩展的、异步的 https://json-schema.org/[Json Schema] 规范实现。
你可以使用 Json Schemas 去校验每一个json结构的数据。这个组件提供以下特性：
Vert.x Json Schema provides an extendable and asynchronous implementation for https://json-schema.org/[Json Schema] specification.
You can use Json Schemas to validate every json structure. This module provides:

* 实现了 https://tools.ietf.org/html/draft-handrews-json-schema-validation-02[Json Schema draft2019-09]
* 实现了 https://tools.ietf.org/html/draft-handrews-json-schema-validation-01[Json Schema draft-7]
* 实现了 https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#schemaObject[OpenAPI 3 dialect].
* 非阻塞的 `$ref` 引用和缓存 Non blocking `$ref` resolution and caching
* 使用 `link:../../apidocs/io/vertx/core/json/pointer/JsonPointer.html[JsonPointer]` 查找缓存
* 支持同步和异步校验
* 可以添加新的关键字和新的格式条件来扩展校验树 Ability to extend the validation tree adding new keywords and new format predicates
* 以DSL编程方式来构建schemas  DSL to build schemas programmatically

== 使用 Vert.x Json Schema

为了使用Vert.x Json Schema，需要在构建描述符中添加如下 _依赖_：

* Maven (在`pom.xml`文件中):

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-json-schema</artifactId>
 <version>4.0.2</version>
</dependency>
----

* Gradle (在 `build.gradle` 文件中):

[source,groovy,subs="+attributes"]
----
dependencies {
 compile 'io.vertx:vertx-json-schema:4.0.2'
}
----

== 相关概念

=== Schema

每一个schema都可以解析成 `link:../../apidocs/io/vertx/json/schema/Schema.html[Schema]` 实例，而schema是一个由 `link:../../apidocs/io/vertx/json/schema/common/Validator.html[Validator]` 对象组成的树，树中的每一个元素都包含了必要的校验逻辑。
这种校验具有 快速失败 的特性：一旦遇到验证错误，验证就会失败而不再继续

=== SchemaParser 和 SchemaRouter

`link:../../apidocs/io/vertx/json/schema/SchemaParser.html[SchemaParser]` 是一个将json数据结构的schemas解析成 `link:../../apidocs/io/vertx/json/schema/Schema.html[Schema]` 实例的组件。
`link:../../apidocs/io/vertx/json/schema/SchemaRouter.html[SchemaRouter]` 组件可以将schemas解析后进行缓存，以及处理 `$ref` 引用。
一旦一个新的 `$ref` 被处理或者 `link:../../apidocs/io/vertx/json/schema/SchemaParser.html[SchemaParser]` 解析一个新的schema，这个schema都会被缓存到相应的 `link:../../apidocs/io/vertx/json/schema/SchemaRouter.html[SchemaRouter]` 中去。
`link:../../apidocs/io/vertx/json/schema/SchemaParser.html[SchemaParser]` 可以进行扩展并且支持自定义的关键字和格式化。

当前提供的 `link:../../apidocs/io/vertx/json/schema/SchemaParser.html[SchemaParser]` 有：

* `link:../../apidocs/io/vertx/json/schema/draft201909/Draft201909SchemaParser.html[Draft201909SchemaParser]` for Json Schema Draft 2019-09
* `link:../../apidocs/io/vertx/json/schema/draft7/Draft7SchemaParser.html[Draft7SchemaParser]` for Json Schema Draft 7
* `link:../../apidocs/io/vertx/json/schema/openapi3/OpenAPI3SchemaParser.html[OpenAPI3SchemaParser]` for OpenAPI 3 dialect

== 解析schema

要想解析schema首先你需要一个schema router和一个schema parser来匹配你的schema _方言_ 。
例如，实例化一个 _draft 2019-09_ schema parser：

[source,java]
----
SchemaRouter schemaRouter = SchemaRouter.create(vertx, new SchemaRouterOptions());
SchemaParser schemaParser = SchemaParser.createDraft201909SchemaParser(schemaRouter);
----

针对不同的 `SchemaParser` 你可以复用同一个 `SchemaRouter` 实例，并且你可以使用相同的 `SchemaParser` 解析不同的 `Schema` 。

现在你可以解析schema了：

[source,java]
----
Schema schema = parser.parse(object, schemaPointer);
----

当你解析schema时必须要指定一个 **schema pointer**，这个 pointer 是定位schema的一个标识。
如果你没有指定schema pointer，`SchemaParser` 默认会生成一个。
When you parse a schema you must provide the **schema pointer**, a pointer that identifies the location of the schema.
If you don't have any schema pointer `SchemaParser` will generate one for you:

[source,java]
----
Schema schema = parser.parse(object);
schema.getScope(); // 获取schema的生成作用域 (schema pointer)
----

[注意]
====
需要注意的是，当使用 $ref` 引用schema或者处理相关的引用时，schema pointer 是必须的，
如果你从文件系统中加载schema并且使用相关引用，**必须提供正确的pointer**，
否则 `SchemaRouter` 将不能处理本地文件系统的 `$ref`。
====

== 校验

一个schema可以有两种状态：

* 同步状态: 校验树支持同步校验，你可以分别使用 `link:../../apidocs/io/vertx/json/schema/Schema.html#validateSync-java.lang.Object-[validateSync]` 和 `link:../../apidocs/io/vertx/json/schema/Schema.html#validateAsync-java.lang.Object-[validateAsync]` 来校验你的json。
* 异步状态：校验树存在一个或多个分支时需要使用异步校验，你必须使用 `link:../../apidocs/io/vertx/json/schema/Schema.html#validateAsync-java.lang.Object-[validateAsync]` 方法来校验json，如果你使用 `link:../../apidocs/io/vertx/json/schema/Schema.html#validateSync-java.lang.Object-[validateSync]` 来校验则会抛出 `link:../../apidocs/io/vertx/json/schema/NoSyncValidationException.html[NoSyncValidationException]` 异常。
* Synchronous: The validators tree can provide a synchronous validation. You can validate your json both using `link:../../apidocs/io/vertx/json/schema/Schema.html#validateSync-java.lang.Object-[validateSync]` and `link:../../apidocs/io/vertx/json/schema/Schema.html#validateAsync-java.lang.Object-[validateAsync]`</li>
* Asynchronous: One or more branches of the validator tree requires an asynchronous validation. You must use `link:../../apidocs/io/vertx/json/schema/Schema.html#validateAsync-java.lang.Object-[validateAsync]` to validate your json. If you use `link:../../apidocs/io/vertx/json/schema/Schema.html#validateSync-java.lang.Object-[validateSync]` it will throw a `link:../../apidocs/io/vertx/json/schema/NoSyncValidationException.html[NoSyncValidationException]`</li>

通过异步状态来校验 schema：

[source,java]
----
schema.validateAsync(json).onComplete(ar -> {
  if (ar.succeeded()) {
    // 校验成功
  } else {
    // 校验失败
    ar.cause(); // 包含校验的异常情况
  }
});
----

通过同步状态来校验schema：

[source,java]
----
try {
  schema.validateSync(json);
  // 校验成功
} catch (ValidationException e) {
  // 校验失败
} catch (NoSyncValidationException e) {
  // 必须使用异步校验，不能使用同步校验
}
----

你可以使用 `link:../../apidocs/io/vertx/json/schema/Schema.html#isSync--[isSync]` 方法来获取schema的当前状态。
schema可以实时切换状态，比如，如果你有一个schema使用 `$ref` 引用了外部的schema，
此时它处于异步状态，在第一次校验之后，外部schema被缓存了，这时schema将会切换到同步状态。

[注意]
====
如果schema在同步状态下使用 `link:../../apidocs/io/vertx/json/schema/Schema.html#validateAsync-java.lang.Object-[validateAsync]` 方法来校验，
这个schema将会在返回的 `Future` 中同步包含校验的结果，从而避免了不必要的异步计算和内存占用。
====

== 设置默认值

你可以通过 `JsonObject` 和 `JsonArray` 来设置默认值

[source,java]
----
schema.applyDefaultValues(jsonObject);
// 或
schema.applyDefaultValues(jsonArray);
----

这个方法将改变所提供的Json结构的内部状态。

== 添加自定义格式

你可以在解析schemas之前使用校验关键字 `format` 来自定义数据格式。

[source,java]
----
parser.withStringFormatValidator("firstUppercase", str -> Character.isUpperCase(str.charAt(0)));

JsonObject mySchema = new JsonObject().put("format", "firstUppercase");
Schema schema = parser.parse(mySchema);
----

== 自定义关键词
每当你想要添加一个新的关键词类型时，你必须要实现 `link:../../apidocs/io/vertx/json/schema/common/ValidatorFactory.html[ValidatorFactory]` ，
然后使用 `link:../../apidocs/io/vertx/json/schema/SchemaParser.html#withValidatorFactory-io.vertx.json.schema.common.ValidatorFactory-[withValidatorFactory]` 提供一个实例给 `SchemaParser`。
当解析开始时，`SchemaParser` 将会调用每一个注册的工厂的 `link:../../apidocs/io/vertx/json/schema/common/ValidatorFactory.html#canConsumeSchema-io.vertx.core.json.JsonObject-[canConsumeSchema]` 方法。
如果工厂可以使用这个schema，那么就会调用 `link:../../apidocs/io/vertx/json/schema/common/ValidatorFactory.html#createValidator-io.vertx.core.json.JsonObject-io.vertx.core.json.pointer.JsonPointer-io.vertx.json.schema.common.SchemaParserInternal-io.vertx.json.schema.common.MutableStateValidator-[createValidator]` 方法。
这个方法返回一个执行校验的 `link:../../apidocs/io/vertx/json/schema/common/Validator.html[Validator]` 对象实例，
如果在 `Validator` 初始化过程中发生错误，将会抛出 `link:../../apidocs/io/vertx/json/schema/SchemaException.html[SchemaException]` 异常。
For every new keyword type you want to provide, you must implement `link:../../apidocs/io/vertx/json/schema/common/ValidatorFactory.html[ValidatorFactory]`
and provide an instance to `SchemaParser` using `link:../../apidocs/io/vertx/json/schema/SchemaParser.html#withValidatorFactory-io.vertx.json.schema.common.ValidatorFactory-[withValidatorFactory]`.
When parsing happens, the `SchemaParser` calls `link:../../apidocs/io/vertx/json/schema/common/ValidatorFactory.html#canConsumeSchema-io.vertx.core.json.JsonObject-[canConsumeSchema]` for each registered factory.
If the factory can consume the schema, then the method `link:../../apidocs/io/vertx/json/schema/common/ValidatorFactory.html#createValidator-io.vertx.core.json.JsonObject-io.vertx.core.json.pointer.JsonPointer-io.vertx.json.schema.common.SchemaParserInternal-io.vertx.json.schema.common.MutableStateValidator-[createValidator]`
is called. This method returns an instance of `link:../../apidocs/io/vertx/json/schema/common/Validator.html[Validator]`, that represents the object that will perform the validation.
If something goes wrong during `Validator` creation, a `link:../../apidocs/io/vertx/json/schema/SchemaException.html[SchemaException]` should be thrown

You can add custom keywords of three types:
你可以自定义以下三种类型的关键词：

* 总是同步校验输入的关键词
* 总是异步校验输入的关键词
* 可变状态的关键词

=== 同步状态的关键词

同步校验器必须要实现 `link:../../apidocs/io/vertx/json/schema/common/SyncValidator.html[SyncValidator]` 接口。
Synchronous validators must implement the interface `link:../../apidocs/io/vertx/json/schema/common/SyncValidator.html[SyncValidator]`.
In the example below I add a keyword that checks if the number of properties in a json object is a multiple of a provided number:

[source,java]
----
`link:../../apidocs/examples/PropertiesMultipleOfValidator.html[PropertiesMultipleOfValidator]`
----

After we defined the keyword validator we can define the factory:

[source,java]
----
`link:../../apidocs/examples/PropertiesMultipleOfValidatorFactory.html[PropertiesMultipleOfValidatorFactory]`
----

Now we can mount the new validator factory:

[source,java]
----
parser.withValidatorFactory(new PropertiesMultipleOfValidatorFactory());

JsonObject mySchema = new JsonObject().put("propertiesMultipleOf", 2);
Schema schema = parser.parse(mySchema);
----

=== Asynchronous keywords

Synchronous validators must implement the interface `link:../../apidocs/io/vertx/json/schema/common/AsyncValidator.html[AsyncValidator]`.
In this example I add a keyword that retrieves from the Vert.x Event bus an enum of values:

[source,java]
----
`link:../../apidocs/examples/AsyncEnumValidator.html[AsyncEnumValidator]`
----

After we defined the keyword validator we can define the factory:

[source,java]
----
`link:../../apidocs/examples/AsyncEnumValidatorFactory.html[AsyncEnumValidatorFactory]`
----

Now we can mount the new validator factory:

[source,java]
----
parser.withValidatorFactory(new AsyncEnumValidatorFactory(vertx));

JsonObject mySchema = new JsonObject().put("asyncEnum", "enums.myapplication");
Schema schema = parser.parse(mySchema);
----

== Building your schemas from code

If you want to build schemas from code, you can use the included DSL. Only Draft-7 is supported for this feature.

To start, add static imports for `link:../../apidocs/io/vertx/json/schema/draft7/dsl/Schemas.html[Schemas]` and `link:../../apidocs/io/vertx/json/schema/draft7/dsl/Keywords.html[Keywords]`

=== Creating the schema

Inside `link:../../apidocs/io/vertx/json/schema/draft7/dsl/Schemas.html[Schemas]` there are static methods to create the schema:

[source,java]
----
SchemaBuilder intSchemaBuilder = intSchema();
SchemaBuilder objectSchemaBuilder = objectSchema();
----

=== Using the keywords

For every schema you can add keywords built with `link:../../apidocs/io/vertx/json/schema/draft7/dsl/Keywords.html[Keywords]` methods,
depending on the type of the schema:

[source,java]
----
stringSchema()
  .with(format(StringFormat.DATETIME));
arraySchema()
  .with(maxItems(10));
schema() // Generic schema that accepts both arrays and integers
  .with(type(SchemaType.ARRAY, SchemaType.INT));
----

=== Defining the schema structure

Depending on the schema you create, you can define a structure.

To create an object schema with some properties schemas and additional properties schema:

[source,java]
----
objectSchema()
  .requiredProperty("name", stringSchema())
  .requiredProperty("age", intSchema())
  .additionalProperties(stringSchema());
----

To create an array schema:

[source,java]
----
arraySchema()
  .items(stringSchema());
----

To create a tuple schema:

[source,java]
----
tupleSchema()
  .item(stringSchema()) // First item
  .item(intSchema()) // Second item
  .item(booleanSchema()); // Third item
----

=== `$ref` and aliases

To add a `$ref` schema you can use the `link:../../apidocs/io/vertx/json/schema/common/dsl/Schemas.html#ref-io.vertx.core.json.pointer.JsonPointer-[Schemas.ref]` method.
To assign an `$id` keyword to a schema, use `link:../../apidocs/io/vertx/json/schema/common/dsl/SchemaBuilder.html#id-io.vertx.core.json.pointer.JsonPointer-[id]`

You can also refer to schemas defined with this dsl using aliases. You can use `link:../../apidocs/io/vertx/json/schema/common/dsl/SchemaBuilder.html#alias-java.lang.String-[alias]` to assign an alias to
a schema. Then you can refer to a schema with an alias using `link:../../apidocs/io/vertx/json/schema/common/dsl/Schemas.html#refToAlias-java.lang.String-[Schemas.refToAlias]`:

[source,java]
----
intSchema()
  .alias("myInt");

objectSchema()
  .requiredProperty("anInteger", refToAlias("myInt"));
----

=== Using the schema

After you defined the schema, you can call `link:../../apidocs/io/vertx/json/schema/common/dsl/SchemaBuilder.html#build-io.vertx.json.schema.SchemaParser-[build]` to parse and use the schema:

[source,java]
----
Schema schema = objectSchema()
  .requiredProperty("name", stringSchema())
  .requiredProperty("age", intSchema())
  .additionalProperties(stringSchema())
  .build(parser);
----