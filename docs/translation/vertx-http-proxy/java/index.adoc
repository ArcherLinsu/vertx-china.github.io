= Vert.x Http Proxy
:toc: left

Vert.x Http Proxy 是一个基于 Vert.x 的反向代理服务器，其目的是实现可重用的反向代理逻辑，
这样，使用者就可以关注更高层面的问题了

WARNING: 这个模块处于 _Tech Preview_ 阶段，这意味着在不同版本之间 API 可能会不太一样

[[_using_vert_x_http_proxy]]
== 使用 Vert.x Http Proxy

使用 Vert.x Http Proxy 之前，请把以下的依赖放到您的构建描述文件的 _依赖_ 部分中

* Maven （在您的 `pom.xml` 文件中）：

[source,xml,subs="+attributes"]
----
<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-http-proxy</artifactId>
 <version>4.2.5</version>
</dependency>
----

* Gradle （在您的 `build.gradle` 文件中）：

[source,groovy,subs="+attributes"]
----
dependencies {
 compile 'io.vertx:vertx-http-proxy:4.2.5'
}
----

== Reverse proxy server

为了使用 Vert.x Http Proxy 实现一个反向代理，您需要了解这些名词：

1. *Proxy Server* that handles user-agent requests and forward them to the *origin server*
2. *Origin Server* that handles requests from the *proxy server* and respond accordingly

You can create a *proxy server* that listens to port `8080` and implement reverse proxy logic

[source,java]
----
HttpClient proxyClient = vertx.createHttpClient();

HttpProxy proxy = HttpProxy.reverseProxy(proxyClient);
proxy.origin(7070, "origin");

HttpServer proxyServer = vertx.createHttpServer();

proxyServer.requestHandler(proxy).listen(8080);
----

All user-agent requests are forwarded to the *origin server* conveniently.

[[_websockets]]
=== WebSockets

该 HTTP 代理默认支持 WebSocket 协议。

WebSocket 的握手请求会被转发到源服务器 (包含 `connection` 头部) ，并且用户端
和源服务器间会发生握手。

您可以通过 `link:../../apidocs/io/vertx/httpproxy/ProxyOptions.html#setSupportWebSocket-boolean-[setSupportWebSocket]` 方法来设置其是否支持 WebSocket 协议。

[[_proxy_caching]]
=== 代理缓存

大部分情况下，代理不会缓存响应内容，并且会忽视大部分的缓存指令，您也可以使用缓存选项来开启缓存。

[source,java]
----
HttpProxy proxy = HttpProxy.reverseProxy(new ProxyOptions().setCacheOptions(new CacheOptions()), proxyClient);
----

=== Proxy interception

Interception is a powerful way to extend the proxy withg new features.

You can implement `link:../../apidocs/io/vertx/httpproxy/ProxyInterceptor.html#handleProxyRequest-io.vertx.httpproxy.ProxyContext-[handleProxyRequest]` to perform any operation on the proxy request

[source,java]
----
proxy.addInterceptor(new ProxyInterceptor() {
  @Override
  public Future<ProxyResponse> handleProxyRequest(ProxyContext context) {
    ProxyRequest proxyRequest = context.request();

    filter(proxyRequest.headers());

    // Continue the interception chain
    return context.sendRequest();
  }
});
----

Likewise with the proxy response

[source,java]
----
proxy.addInterceptor(new ProxyInterceptor() {
  @Override
  public Future<Void> handleProxyResponse(ProxyContext context) {
    ProxyResponse proxyResponse = context.response();

    filter(proxyResponse.headers());

    // Continue the interception chain
    return context.sendResponse();
  }
});
----

==== Body filtering

You can filter body by simply replacing the original `link:../../apidocs/io/vertx/httpproxy/Body.html[Body]` with a new one

[source,java]
----
proxy.addInterceptor(new ProxyInterceptor() {
  @Override
  public Future<Void> handleProxyResponse(ProxyContext context) {
    ProxyResponse proxyResponse = context.response();

    // Create a filtered body
    Body filteredBody = filter(proxyResponse.getBody());

    // And then let the response use it
    proxyResponse.setBody(filteredBody);

    // Continue the interception chain
    return context.sendResponse();
  }
});
----

==== Interception control

`link:../../apidocs/io/vertx/httpproxy/ProxyContext.html#sendRequest--[sendRequest]` and `link:../../apidocs/io/vertx/httpproxy/ProxyContext.html#sendResponse--[sendResponse]` continue the
current interception chain and then send the result to the origin server or the user-agent.

You can change the control, e.g you can send a response immediately to the user-agent without even requesting the origin server

[source,java]
----
proxy.addInterceptor(new ProxyInterceptor() {
  @Override
  public Future<ProxyResponse> handleProxyRequest(ProxyContext context) {

    ProxyRequest proxyRequest = context.request();

    // Release the underlying resources
    proxyRequest.release();

    // Create a response and populate it
    ProxyResponse proxyResponse = proxyRequest.response()
      .setStatusCode(200)
      .putHeader("content-type", "text/plain")
      .setBody(Body.body(Buffer.buffer("Hello World")));

    return Future.succeededFuture(proxyResponse);
  }
});
----